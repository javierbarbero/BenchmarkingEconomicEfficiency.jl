var documenterSearchIndex = {"docs":
[{"location":"cost/costddf/#Cost-Directional-Distance-Function-model","page":"Cost Directional Distance Function model","title":"Cost Directional Distance Function model","text":"The cost directional distance function model is computed by solving an input-oriented directional distance function DEA model for the technical efficiency.\n\nThe directional distance function DDF, projects firm left( mathbfx_omathbfy_o right) to the production frontier  in the pre-assigned direction mathbfg= left(mathbfg_x^-mathbfg^+_y right)neqmathbf0_M+N, mathbfg^-_xmathbbin R^M and mathbfg^+_ymathbbin R^N.   Decomposing cost  inefficiency requires defining the input-oriented directional distance functions. Departing from the general definition this implies setting the output directional vector to zero; i.e., mathbfg= left(mathbfg_x^-mathbfg_y^+ right)=left(mathbfg_textbfx^-textbf0 right). Therefore the input-oriented directional distance functions define as follows:\n\nTI_DDF(I)left( textbfx_otextbfy_o textbfg_textbfx^- textbf0 right)=max left beta_I left( textbfx_o-beta_Itextbfg_textbfx^-textbfy_o right) in L(textbfy_o) beta_I ge 0 right\n\nThe linear programs that allows calculating this measure is: \n\nbeginsplit\n TI_DDF(I)left( mathbfx_omathbfy_o right)=undersetbeta_I_lambda mathoptextmaxbeta_I    \n st quad  sumlimits_jin J^lambda _jx_jmle x_om-beta_I g_x_m^-m=1M   \n quad quad sumlimits_jin J^lambda _jy_jnge y_onn=1N  \n quad quad sumlimits_jin J^lambda _j=1  \n quad quad lambda _jge 0jin J  \nendsplit\n\nOnce again, as in the graph case already presented for the Profit Directional Distance Function model, the choice of directional vector corresponds to the researcher. Customarily, to keep consistency with the radial models, the observed amounts of inputs set the direction: mathbfg= left(mathbfg_x^-mathbfg_y^+ right)=left(mathbfx_otextbf0right). In this case it can be shown that the directional model nests the Radial Input Oriented Model. Indeed, if left(mathbfg_x^-mathbfg^+_y right)= left( mathbfx_omathbf0 right), then beta_I^*=1-theta^* (in the Cost Radial model. However, other choices are available, which are included as options in BenchmarkingEconomicEfficiency.jl–see the documentation below accompanying this function.     \n\nThe notion of Nerlovian cost inefficiency corresponds to the decompostion of economic efficiency based on the input-oriented directional distance function: CI_DDFleft( I right)left( textbfx_otextbfy_omathbfg_x^-tildetextbfw right) = TI_DDFleft( I right)left( textbfx_otextbfy_omathbfg_x^- right) + AI_DDFleft( I right)left( textbfx_otextbfy_omathbfg_x^-  tildetextbfw right). This results in the following expression: \n\nunderbracefracsumlimits_m=1^Mw_mx_om-Cleft( textbfy_o textbfw right)sumlimits_m=1^Mw_m^g_om^-_textNorm Cost Inefficiency=underbracebeta_O^*_textTechnical Inefficiency+underbraceAI_DDFleft( I right)left( textbfx_otextbfy_omathbfg_x^-tildetextbfw right)_textNorm Allocative Inefficiency ge 0\n\nReference\n\nChapter 8 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the cost efficiency directional distance function measure using the option Gx=:Monetary.\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\nW = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\ncostddf = deacostddf(X, Y, W, Gx = :Monetary)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(costddf, :Economic)\n\nefficiency(costddf, :Technical)\n\nefficiency(costddf, :Allocative)","category":"section"},{"location":"cost/costddf/#deacostddf-Function-Documentation","page":"Cost Directional Distance Function model","title":"deacostddf Function Documentation","text":"","category":"section"},{"location":"cost/costddf/#BenchmarkingEconomicEfficiency.deacostddf","page":"Cost Directional Distance Function model","title":"BenchmarkingEconomicEfficiency.deacostddf","text":"deacostddf(X, Y, W; Gx)\n\nCompute cost efficiency using directional distance function DEA model for inputs X, outputs Y and price of inputs W.\n\nDirection specification:\n\nThe direction Gx can be one of the following symbols.\n\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n:Monetary: use direction so that profit inefficiency is expressed in monetary values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"revenue/revenueefficiency/#Revenue-(In)Efficiency-measurement","page":"Revenue (In)Efficiency measurement","title":"Revenue (In)Efficiency measurement","text":"Revenue efficiency allows studying the economic performance of firms as revenue maximizers; i.e. their ability to maximize the revevenue of producing with a given level of inputs given output prices. Revenue efficiency (inefficency) can be measured and decomposed multiplicatively (additively), depending on the (in)efficiency measure that is employed. The multiplicative approach is most well-known as it corresponds to Farrell's radial dproposal. For this reason we initiate the presentation of the revenue models with this approach and then follow with the many additive decompositions that have been proposed in the literature, based on the different output-oriented inefficiency measures, denoted by EM(O), that can be also found in the profit and cost approaches. \n\nIn this case, measuring economic efficiency requires the definition of the optimal economic goal of the firm, which corresponds to the maximum revenue that can be obtainable from input level \\textbf{x}, represented by the output set P(textbfx_o). The revenue function is expressed as: \n\nR(mathbfxmathbfp)=undersetmathbfymathoptextmaxleft mathbfpcdot mathbfy  mathbfx_o ge\nYmathbflambda mathbfmathbfelambda=1 lambda  \tge mathbf0 right  mathbfpin mathbbR_++^Nmathbfx_oge 0_N\n\n. \n\nMaximum revenue along with the optimal output  quantities can be calculated through DEA by solving the following model  \n\nbeginsplit\n Rleft( mathbfx_omathbfp right)=undersettextbfypmblambda mathopmax  sumnolimits_n=1^Np_ny_n  \n textstextttextquad sumnolimits_j=1^Jlambda _j^x_jm^le  x_om m=1Mtext   \n quad quad sumnolimits_j=1^Jlambda _j^y_jn^ge y_n^ n=1Ntext   \n quad quad sumnolimits_j=1^Jlambda _j^=1  \n quad quad lambda ge 0  \nendsplit\n\nMultiplicative decomposition revenue efficiency\n\nFor firm left( textbfx_o^textbfy_o^ right), revenue efficiency defines as the ratio of observed revenue to maximum revenue; i.e, \n\nmathitRE(textbfx_otextbfy_o textbfp)= R_oRleft(mathbfx_omathbfpright)=mathbfpcdot mathbfy_oRleft(mathbfx_omathbfpright)= \nsumlimits_n=1^Np_ny_onRleft(mathbfx_omathbfpright) le 1\n\nTherefore if mathitRE(textbfx_otextbfy_otextbfp) = 1 the firm maximizes revenue, and the smaller the value of the revenue efficiency, the greater the revenue loss.    \n\nBased on the duality between the rvenue function and the radial output measure, it is possible  to decompose revenue efficiency multiplicatively into a measure of technical efficiency and a residual measure of allocative inefficiency. This methoid is presented in the following section Revenue Radial model.  \n\nAdditive decompositions of revenue inefficiency\n\nRevenue inefficiency can be defined as the difference between maximum revenue and observed revenue: \n\nmathitRI(textbfx_otextbfy_o textbfp)= Rleft(mathbfx_omathbfpright) - R_o = Rleft(mathbfx_omathbfpright) - mathbfpcdot mathbfy_o= Rleft(mathbfx_omathbfpright)-sumlimits_n=1^Np_ny_on ge 0\n\nTherefore if mathitRI(textbfx_otextbfy_otextbfp) = 0 the firm maximizes revenue, and the greater the value of the revenue inefficiency, the greater the revenue loss.    \n\nFollowing the literature the decomposition of revenue inefficiency can be performed based on different output-oriented technical inefficiency measures. Regardless the particular ineffiency measure, EM(O), revenue inefficiency is decomposed into an output technical inefficiency measure, generally denoted by TI_EM(O)(textbfx_o textbfy_o), and an allocative term. Regarding efficiency measurement,  if a firm is technically efficient, the efficiency score is null, i.e, EM(O) = 0. On the contrary, if the inefficiency score is positive, the firm is technically inefficient.  After calculating the output-oriented technical inefficiency, and based on the duality between the revenue function and each technical inefficiency measure, we can establish two Fenchel-Mahler inequalities by which normalized revenue inefficiency:  mathitRI(textbfx_otextbfy_otildetextbfp)=  mathitRI(textbfx_otextbfy_otextbfp)NF_EM(O), is greater or equal in value to the output-oriented technical efficiency measure, i.e., mathitRI(textbfx_otextbfy_otextbfp)NF_EM(O) ge TI_EM(O)(textbfx_o textbfy_o).\n\nThe divisor NF_EM(O) is a normalizing scalar derived from the duality relationship. Afterwards, a scalar representing normalized allocative inefficiency is obtained as a residual by closing the inequality. Revenue allocative inefficiency measures the revenue loss that can be attributed to the fact that firm (or its technically projected benchmark) does not supply the optimal output quantities.\n\nNormalized revenue inefficiency can be decomposed then as follows: \n\nunderbrace     frac sumlimits_m=1^Mw_mx_om - C left( mathbfy_omathbfw right)NF_EM(I)_textNormtext Cost Inefficiency \nquad =underbraceTI_EM(I)(textbfx_o textbfy_o)_textInput Technical Inefficiency+ underbraceAI_EM(I)left( mathbfx_omathbfy_omathbftildewright)_textNormtext Allocative Inefficiency ge 0    \n\nThe following functions available in BenchmarkingEconomicEfficiency.jl present alternative decompositions of revenue inefficiency based on the most relevant technical inefficiency measures proposed in the literature. As for the decompositions, being normalized, they all satisfy the property of commensurability (or units' invariance), and therefore they are independent of the units of measurement of quantities and prices. Additionally, each of these measures results in a particular decomposition whose pros and cons in terms of a series of properties are inherited from those of the underlying technical inefficiency measure: TI_EM(O)(textbfx_o textbfy_o). Pastor, Aparicio and Zofío (2022, Chap. 14) discuss the properties of the different decompositions. \n\nReference\n\nChapter 2 and 14 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. ","category":"section"},{"location":"revenue/revenueddf/#Revenue-Directional-Distance-Function-model","page":"Revenue Directional Distance Function model","title":"Revenue Directional Distance Function model","text":"The revenue directional distance function model is computed by solving a directional distance function DEA model for the technical efficiency.\n\nThe directional distance function DDF, projects firm left( mathbfx_omathbfy_o right) to the production frontier  in the pre-assigned direction mathbfg= left(mathbfg_x^-mathbfg^+_y right)neqmathbf0_M+N, mathbfg^-_xmathbbin R^M and mathbfg^+_ymathbbin R^N. Decomposing  revenue inefficiency requires defining the output-oriented directional distance functions. Departing from the general definition this implies setting the output or input directional vectors to zero; i.e., mathbfg= left(mathbfg_x^-mathbfg_y^+ right)=left(textbf0textbfg_textbfy^+ right), respectively. Therefore the output-oriented directional distance functions defines as follows:\n\nTI_DDF(O)left( textbfx_otextbfy_o textbf0textbfg_textbfy^+ right)=max left beta_O left( textbfx_otextbfy_o+beta_Otextbfg_textbfy^+ right)in P(textbfx_o) beta_Oge 0 right\n\nThe linear programs that allows calculating this measure is: \n\nbeginsplit\n TI_DDF(O)left( mathbfx_omathbfy_o right)=undersetbeta_O _lambda mathoptextmaxbeta_O     \n st quad sumlimits_jin J^lambda _jx_jmle x_omm=1M   \n quad quad sumlimits_jin J^lambda _jy_jnge y_on+beta g_y_n^+n=1N   \n quad quad sumlimits_jin J^lambda _j=1   \n quad quad lambda _jge 0jin J \nendsplit\n\nOnce again, as in the graph case already presented for the Profit Directional Distance Function model, the choice of directional vector corresponds to the researcher. Customarily, to keep consistency with the radial models, the observed amounts of outputs set the direction: mathbfg= left(mathbfg_x^-mathbfg_y^+ right)=left(textbf0mathbfy_oright). In this case it can be shown that the directional model nests  Radial Output Oriented Model. Indeed, if left(mathbfg_x^-mathbfg^+_y right)=left( mathbf0mathbfy_o right), then beta_O^*=phi^*-1 (in the Revenue Radial model. However, other choices are available, which are included as options in BenchmarkingEconomicEfficiency.jl–see the documentation below accompanying this function.       \n\nThe notion of Nerlovian revenue inefficiency corresponds to the decompostion of economic efficiency based on the output-oriented directional distance function: RI_DDFleft( O right)left( textbfx_otextbfy_omathbfg_y^+tildetextbfp right) = TI_DDFleft( O right)left( textbfx_otextbfy_omathbfg_y^+ right) + AI_DDFleft( O right)left( textbfx_otextbfy_omathbfg_y^+ tildetextbfp right). This results in the following expression: \n\nunderbracefracR left( mathbfx_omathbfp right) - sumlimits_n=1^Np_ny_om sumlimits_n=1^Np_n^g_on^+_textNorm Revenue Inefficiency=underbracebeta_I^*_textTechnical Inefficiency+underbraceAI_DDFleft( I right)left( textbfx_otextbfy_omathbfg_y^+tildetextbfp right)_textNorm Allocative Inefficiency ge 0\n\nReference\n\nChapter 8 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the revenue efficiency directional distance function measure using the option Gy=:Monetary.\n\nusing BenchmarkingEconomicEfficiency\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5];\n\nP = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\nrevenueddf = dearevenueddf(X, Y, P, Gy = :Monetary)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(revenueddf, :Economic)\n\nefficiency(revenueddf, :Technical)\n\nefficiency(revenueddf, :Allocative)","category":"section"},{"location":"revenue/revenueddf/#dearevenueddf-Function-Documentation","page":"Revenue Directional Distance Function model","title":"dearevenueddf Function Documentation","text":"","category":"section"},{"location":"revenue/revenueddf/#BenchmarkingEconomicEfficiency.dearevenueddf","page":"Revenue Directional Distance Function model","title":"BenchmarkingEconomicEfficiency.dearevenueddf","text":"dearevenueddf(X, Y, P; Gy)\n\nCompute revenue efficiency using directional distance function data envelopment analysis for inputs X, outputs Y and price of outputs P.\n\nDirection specification:\n\nThe direction Gy can be one of the following symbols.\n\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n:Monetary: use direction so that profit inefficiency is expressed in monetary values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profitability/profitability/#Profitability-model","page":"Profitability Efficiency measurement","title":"Profitability model","text":"The profitability directional model is computed by solving the Generalized Distance Function DEA Model for the technical efficiency.\n\nProfitability inefficiency studies economic performance considering as economic goal the maximization of revenue to cost. The profitability function represents the maximum revenue to cost given the technology and input and output prices. It defines as follows:\n\nGamma left(mathbfwmathbfpright)=undersetmathbfxmathbfymathoptextmaxBigmathbfpcdot mathbfymathbfwcdot mathbfx  mathbfx ge Xmathbflambdamathbfy leqslant Ymathbflambda  lambda  ge mathbf0 Big mathbfwin mathbbR_++^M mathbfpin mathbbR_++^N\n\nCalculating maximum profitability along with the optimal output and input quantities requires solving:\n\nbeginsplit\n Gamma left( mathbfwmathbfp right)=undersettextbfxtextbfypmblambdamathopmax   sumlimits_n=1^Np_ny_nsumlimits_m=1^Mw_mx_mquad   \n textstextttextquad sumlimits_j=1^Jlambda _jx_jm^le x_m m=1Mtext   \n quad quad sumlimits_j=1^Jlambda _jy_jn^ge y_n^ n=1Ntext   \n quad quad sumlimits_j=1^Jlambda _j^=1  \n quad quad lambda ge 0 \nendsplit\n\nNote that this program allows for variable returns to scale, while the technology exhibits local constant returns at the optimal solution (textbfx^*textbfy^*pmblambda^*). \n\nFor firm left( textbfx_o^textbfy_o^ right)in mathbbR_+^M+N textbfx_o^ne 0_Mtextbfy_o^ne 0_N, Profitability inefficiency defines as the ratio between observed profitability to maximum profitability; i.e., \n\nGamma Eleft( mathbfx_omathbfy_omathbfwmathbfp right)=fracGamma _oGamma (mathbfpmathbfw)=fracmathbfpcdot mathbfy_omathbfwcdot mathbfx_oGamma (mathbfpmathbfw)=fracsumlimits_n=1^Np_ny_onsumlimits_m=1^Mw_mx_omGamma (mathbfpmathbfw)le 1\n\nBased on duality, profitability efficiency is decomposed through graph multiplicative measures that simultaneously reduce inputs and increase outputs. The most popular measure is the hyperbolic graph measure, which is a particular case of the so-called generalized distance function GDF–see Pastor, Aparicio and Zofío (2022, Ch. 4). \n\nThe technical efficiency measure for firm left( textbfx_o^textbfy_o^ right) in terms of the GDF under constant returns to scale can be calculated through DEA methods by solving the following program:  \n\nbeginsplit\n TE^CRS_GDFleft( mathbfx_omathbfy_oalpha  right)=undersettext deltatext mathbfpmblambda mathoptextmin delta ^CRS  \n textstextttext  sumnolimits_j=1^Jlambda _j^x_jm^le left( delta ^CRS right)^1-alpha x_om m=1Mtext   \n quad quad sumnolimits_j=1^Jlambda _j^y_jn^ge y_on^left( delta ^CRS right)^alpha  n=1Ntext  \n quad quad lambda _jge 0   \nendsplit\n\nwhere the parameter alpha sets the direction towards the production frontier. The GDF generalizes existing measures, such as the input distance function (alpha = 0) and the output distance function (alpha = 1). As already mentioned, it also nests the graph (hyperbolic) efficiency technical measure when alpha = 05. \n\nThe fact that the reference benchmark maximizing profitability satisfies constant returns to scale implies that any firm producing under increasing or decreasing returns to scale incurs scale inefficiencies which carry losses in profitability. Therefore, the sources of productive inefficiency can be technical, i.e., the firm lays within the production possibility set, or related to a suboptimal scale, i.e. although the firm (or its projection) may belong to the frontier, it is does not produce under constant returns to scale. This implies that technical efficiency under constant returns to scale can be decomposed into the usual technical efficiency under variables returns to scale times a factor representing scale inefficiency; i.e. TE_GDF^CRSleft( mathbfxmathbfyalpha  right)=TE_GDF^left( mathbfxmathbfyalpha  right)times SE_GDF^left( mathbfxmathbfy alpha  right)=delta times left( delta ^CRSdelta  right)le 1. In this expression, TE_GDF^left( mathbfxmathbfyalpha  right) = delta is the generalized distance function under the variable returns to scale technology T. Its calculation requires solving the previous program but adding the constraint sumnolimits_j=1^Jlambda _j=1. Since both the profitability and the generalized distance function programs are non-linear, BenchmarkingEconomicEfficiency.jl resorts to the 'JuMP' package combined with the `Ipopt' solver.  \n\nOnce both technical efficiency measures have been calculated, we can recall the duality between the profitability function and the GDF. Duality allows establishing the Fenchel-Mahler inequality by which profitability efficiency is greater or equal in value to the technical efficiency measure under CRS, i.e,. mathit Gamma E(textbfx_otextbfy_otextbfw textbfp) ge TE^CRS_GDFleft( mathbfx_omathbfy_oalpha  right). Considering the decomposition of TE^CRS_GDFleft( mathbfx_omathbfy_oalpha  right) into variable returns  efficiency and scale efficiency, and closing the inequality with the addition of the residual term capturing allocative inefficiency, yields the following decomposition:  \n\nbeginsplit\n underbracefracsumlimits_n=1^Np_ny_onsumlimits_m=1^Mw_mx_omGamma (mathbfpmathbfw)_textProfitability Inefficiency=underbraceTE^CRS_GDFleft( mathbfx_omathbfy_oalpha  right)_textGraph Technical Efficiency  CRStimes underbraceAE_GDFleft( mathbfx_omathbfy_omathbfwmathbfp right)_textAllocative Inefficiency = \n underbraceTE_GDFleft( mathbfx_omathbfy_oalpha  right)_textGraph Technical Efficiency  VRS times \nunderbraceSE_GDFleft( mathbfx_omathbfy_oalpha  right)_textScale Efficiency times\n underbraceAE_GDFleft( mathbfx_omathbfy_omathbfwmathbfp right)_textAllocative Inefficiency  ge 0 \nendsplit  \n\nReference\n\nChapter 4 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the profitability efficiency measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitability = deaprofitability(X, Y, W, P)\n\nEstimated economic, technical (CRS and VRS), scale, and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitability, :Economic)\n\nefficiency(profitability, :CRS)\n\nefficiency(profitability, :VRS)\n\nefficiency(profitability, :Scale)\n\nefficiency(profitability, :Allocative)","category":"section"},{"location":"profitability/profitability/#deaprofitability-Function-Documentation","page":"Profitability Efficiency measurement","title":"deaprofitability Function Documentation","text":"","category":"section"},{"location":"profitability/profitability/#DataEnvelopmentAnalysis.deaprofitability","page":"Profitability Efficiency measurement","title":"DataEnvelopmentAnalysis.deaprofitability","text":"deaprofitability(X, Y, W, P)\n\nCompute profitability efficiency using data envelopment analysis for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nalpha=0.5: alpha to use for the generalized distance function.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitholder/#Profit-Hölder-model","page":"Profit Hölder model","title":"Profit Hölder model","text":"The profit Hölder distance function model is computed by solving a graph Hölder DEA model for the technical efficiency.\n\nThe Hölder distance functions conform with the Principle of Least Action (PLA) searching for the closest or 'least distance' to the production frontier. This in contrast to some of the previous models, particularly, those based on slacks such as the Profit Additive model, that maximize the distance to the production frontier, i.e., searches for the furthest targets.  \n\nThe Hölder norms ell _h (hin left 1infty  right) are defined over a g-dimensional real normed space as follows:\n\nleft  right_hzto left z right_h=left beginmatrix\nleft( sumlimits_j=1^gleft z_j right^h right)^1h  textif hin left 1infty  right   \nundersetj=1gmathopmax left left z_j right right  textif h=infty   \nendmatrix right \t\n\nwhere z=left( z_1z_g right)in R^g. \n\nThe choice of a meaningful norm h corresponds to the researcher. BenchmarkingEconomicEfficiency.jl implements the Hölder function under the following norms: unit (h=1), infinitum (h=infty), and h=2, corresponding to the Euclidean distance. Computationally, the Hölder distance functions are related to non-linear optimization programs. However, for h=1 and h=infty it is possible to resort to linear DEA models because the topological balls associated with these norms define polyhedral sets. In these two cases the Hölder distance functions are equivalent to the directional distance function with a specific choice of directional vector. For h=1 it can be shown that TI_WHddotolder(G)left( textbfx_otextbfy_o1 right) is calculated as the minimum of the values TI_DDF(I)left( textbfx_otextbfy_o left(01_left( m right)0 right) textbf0_N right) m=1M, and the values TI_DDF(O)left( x_oy_o textbf0_M left( 01_left( n right)0 right) right) n=1N. These correspond to the input-oriented DDF model, which is solved M times, each with a unit valued element g^-_om=1 for every m input, and the rest of the m-1 elements equal to zero, plus the output-oriented DDF model, which is solved N times, again with a unit valued element, g^+_on=1 for  every n output and the rest of the elements equal to zero. In the case of h=infty,  TI_WHddotolder(G)left( x_oy_o infty right) is identical to the DDF model  with the directional vector fixed at left(mathbfg_x^-mathbfg^+_y right)= left( mathbf1_Mmathbf1_N right). The case of the Euclidean norm h=2 is complex because determining the shortest distance requires minimizing a convex function on the complement of a convex set. Pastor, Aparicio and Zofío (2022, Ch. 9) show that this distance can be calculated resorting to quadratic optimization. The first step to do that consists in writing the Euclidean distance from firm left( mathbfx_omathbfy_o right)  to the weakly efficient frontier as a bi-level linear program, which is a linear program that includes another linear program among its constraints:\n\nbeginsplit\n TI_WHddotolder(G)left( mathbfx_omathbfy_o 2 right)= undersettextbfxtextbfypmblambdabeta pmbgamma mathopmin  sqrtsumlimits_m=1^Mleft( x_om-x_m right)^2+sumlimits_n=1^Nleft( y_n-y_on right)^2  \n\t st quad sumlimits_j=1^Jlambda _jx_jmle x_m quad  m=1M  \n\t  quad quad sumlimits_j=1^Jlambda _jy_jnge y_n quad  n=1N  \n\t quad quad  sumlimits_j=1^Jlambda _j=1   \n\t quad quad beta =0 \n\t quad quad undersetbetapmbgammamathopmax beta    \n\t quad quad stsumlimits_j=1^Jgamma _jx_jmle x_m-beta quad m=1M  \n\t quad quad sumlimits_j=1^Jgamma _jy_jnge y_n+betaquad  n=1N  \n\t quad quad sumlimits_j=1^Jgamma _j=1 \n\t quad quad lambda _jgamma _jge 0 quad j=1J  \n\t quad quad x_mge 0 quad m=1M  \n\t quad quad y_nge 0 quad n=1N  \nendsplit\n\nThe literature presents different ways of solving Bi-level Programing models, from exact methods to heuristics and metaheuristics. Here we use the Karush-Kuhn-Tucker conditions of the linear program embedded in the previous model, corresponding to undersetbeta pmbgammamathopmax beta and its associated contraints. Pastor, Aparicio and Zofío (2022, Ch. 9) show that, substituting this program with the corresponding set of complementary constrainst, one can solve the program through second order sets (SOS). Therefore, the final model to be solved is a quadratic programming problem with SOS conditions. BenchmarkingEconomicEfficiency.jl solves the Hölder  model associated to the Euclidean norm using the Gurobi optimizer. This requires adding it to Julia, which can be done under a free license for academic use only, or a paid commercial version. The optimizer can be downloaded from the company's website. A free academic license can be obtained here. Upon installation, add the package Gurobi.jl to Julia by running the following the commands: 'using Pkg', 'Pkg.add(\"Gurobi\")' and 'Pkg.build(\"Gurobi\")'.    \n\nWe now recall the duality results that allow the decomposition of profit inefficiency into technical and allocative components: PiI_WHddotolder(G)left( textbfx_otextbfy_o h tildetextbfw tildetextbfp right) = TI_WHddotolder(G)left( textbfx_otextbfy_oh right) + AI_WHddotolder(G)left( textbfx_otextbfy_oh tildetextbfw tildetextbfp right). For the Euclidean norm h=2, this results in the following expression: \n\nbeginsplit \n\t underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)left left( wp right) right_q_textNormtext textProfit Inefficiency=  \n\t quad underbracesqrtsumlimits_m=1^Mleft( x_om-x_m^* right)^2+sumlimits_n=1^Nleft( y_n^*-y_on right)^2_textGraph Technnical Inefficiency+underbraceAI_WHddotolderleft( G right)left( textbfx_otextbfy_otildetextbfwtildetextbfph right)_textNormtext textProfit Inefficiencyge 0  \nendsplit\n\nwhere x^*_m and y^*_n are the solution to the DEA problem.\n\nFrom the point of view of the satisfaction of properties, a critique associated with the Hölder distance functions is that they do not satisfy units' invariance because they are dependent on the units of measurement of inputs and outputs. This means that the comparison between the efficiency scores of different observations would change depending on the units of measurement chosen by the analyst. To solve this problem we can rely on the weighted version of the weakly efficient Hölder distance function (denoted as WW)–for details see Pastor, Aparicio and Zofío (2022, Ch. 9). Based on this distance function, we can decompose profit inefficiency into technical and allocative inefficiency terms that are units' invariant: PiI_WWHddotolder(G)left( textbfx_otextbfy_o h tildetextbfw tildetextbfp right) = TI_WWHddotolder(G)left( textbfx_otextbfy_oh right) + AI_WWHddotolder(G)left( textbfx_otextbfy_oh tildetextbfw tildetextbfp right): \n\nbeginsplit \n underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)left left( w_1x_o1w_Mx_oMp_1y_o1p_Ny_oN right) right_q_textNormtext textProfit Inefficiency=  \n quad underbracesqrtsumlimits_m=1^Mleft(fracx_om-x_m^*x_omright)^2+sumlimits_n=1^Nleft(fracy_m^*-y_oy_omright)^2_textGraph Technnical Inefficiency+underbraceAI_WWHddotolderleft( G right)left( textbfx_otextbfy_ohtildetextbfwtildetextbfp right)_textNormtext textProfit Inefficiencyge 0  \nendsplit\n\nBenchmarking Economic Efficiency with Julia calculates both the unweighted and weighted versions of the profit Hölder model under the previous norms: ell _1,  ell _infty , and ell _2. The weighted version requires adding weight=true to the code–see below the documentation accompanying this function for different options.   \n\nReference\n\nChapter 9 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham.\n\nExample\n\nIn this example we compute the profit efficiency Hölder under the L1 norm considering the unweighted version:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitholderl1 = deaprofitholder(X, Y, W, P, l = 1)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitholderl1, :Economic)\n\nefficiency(profitholderl1, :Technical)\n\nefficiency(profitholderl1, :Allocative)","category":"section"},{"location":"profit/profitholder/#deaprofitholder-Function-Documentation","page":"Profit Hölder model","title":"deaprofitholder Function Documentation","text":"","category":"section"},{"location":"profit/profitholder/#BenchmarkingEconomicEfficiency.deaprofitholder","page":"Profit Hölder model","title":"BenchmarkingEconomicEfficiency.deaprofitholder","text":"deaprofitholder(X, Y, W, P; l)\n\nCompute profit efficiency using data envelopment analysis Hölder model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nHölder norm l specification\n\n1.\n2.\nInf.\n\nOptional Arguments\n\nweigt=false:  set to true for weighted (weakly) Hölder distance function.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#Profit-Efficiency-Change","page":"Profit Efficiency Change","title":"Profit Efficiency Change","text":"Example\n\nIn this example we compute the profit efficiency change measure considering a choice of directional vector that returns profit inefficiency in monetary terms:\n\nusing BenchmarkingEconomicEfficiency\n\nX1 = [5 3; 2 4; 4 2; 4 8; 7 9]\nY1 = [7 4; 10 8; 8 10; 5 4; 3 6] \nW1 = [2 1; 2 1; 2 1; 2 1; 2 1]\nP1 = [3 2; 3 2; 3 2; 3 2; 3 2]\n\nX2 = [14 12; 8 10; 10 8; 16 20; 14 17]\nY2 = [18 10; 36 28; 28 36; 18 14; 12 20]\nW2 = [3 4; 3 4; 3 4; 3 4; 3 4]\nP2 = [3 5; 3 5; 3 5; 3 5; 3 5]\n\nX = Array{Float64,3}(undef, 5, 2, 2);\nX[:, :, 1] = X1;\nX[:, :, 2] = X2;\n\nY = Array{Float64,3}(undef, 5, 2, 2);\nY[:, :, 1] = Y1;\nY[:, :, 2] = Y2;\n\nW = Array{Float64,3}(undef, 5, 2, 2);\nW[:, :, 1] = W1;\nW[:, :, 2] = W2;\n\nP = Array{Float64,3}(undef, 5, 2, 2);\nP[:, :, 1] = P1;\nP[:, :, 2] = P2;\n\nprofteffchddf = deaprofitchange(X, Y, W, P, Gx = :Monetary, Gy = :Monetary)\n\nEstimated economic, technical and allocative efficiency change scores are returned with the effchange function:\n\neffchange(profteffchddf, :Economic)\n\neffchange(profteffchddf, :Technical)\n\neffchange(profteffchddf, :Allocative)","category":"section"},{"location":"profit/profitchange/#DEA-Profit-Efficiency-Change-Functions-Documentation","page":"Profit Efficiency Change","title":"DEA Profit Efficiency Change Functions Documentation","text":"","category":"section"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchangeadd","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchangeadd","text":"deaprofitchangeadd(X, Y, W, P, model)\n\nCompute profit efficiency change using data envelopment analysis weighted additive model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nModel specification:\n\n:Ones: standard additive DEA model.\n:MIP: Measure of Inefficiency Proportions. (Charnes et al., 1987; Cooper et al., 1999)\n:Normalized: Normalized weighted additive DEA model. (Lovell and Pastor, 1995)\n:RAM: Range Adjusted Measure. (Cooper et al., 1999)\n:BAM: Bounded Adjusted Measure. (Cooper et al, 2011)\n:Custom: User supplied weights.\n\nOptional Arguments\n\nrhoX: matrix of weights of inputs. Only if model=:Custom.\nrhoY: matrix of weights of outputs. Only if model=:Custom.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchangerussell","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchangerussell","text":"deaprofitchangerussell(X, Y, W, P)\n\nCompute profit efficiency change using Russell data envelopment analysis for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchangeerg","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchangeerg","text":"deaprofitchangeerg(X, Y, W, P)\n\nCompute profit efficiency change using data envelopment analysis Enhanced Russell Graph Slack Based Measure model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchange","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchange","text":"deaprofitchange(X, Y, W, P; Gx, Gy)\n\nCompute profit efficiency change using data envelopment analysis model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n:Monetary: use direction so that profit inefficiency is expressed in monetary values.\n:Euclidean: use prices normalized by the Euclidean norm of all input and output prices so profit inefficiency is the Euclidean distance between profit hyperplanes.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchangeholder","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchangeholder","text":"deaprofichangetholder(X, Y, W, P; l)\n\nCompute profit efficiency change using data envelopment analysis Hölder model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nHölder norm l specification\n\n1.\n2.\nInf.\n\nOptional Arguments\n\nweigt=false:  set to true for weighted (weakly) Hölder distance function.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchangemddf","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchangemddf","text":"deaprofitchangemddf(X, Y, W, P; Gx, Gy)\n\nCompute profit efficiency change using Modified DDF data envelopment analysis model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Observed: use observed values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchangerddf","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchangerddf","text":"deaprofitchangerddf(X, Y, W, P, measure)\n\nCompute profit change efficiency using data envelopment analysis Reverse DDF model for inputs X, outputs Y, price of inputs W, price of outputs P, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph Slack Based Measure.\n:MDDF: Modified Directional Distance Function.\n\nDirection specification:\n\nFor the Modified Directional Distance Function, the directions Gx and Gy can be one of the following symbols.\n\n:Observed: use observed values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\natol=1e-6: tolerance for DMU to be considered efficient.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.deaprofitchangegda","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitchangegda","text":"deaprofitchangegda(X, Y, W, P, measure)\n\nCompute profit efficiency change using data envelopment analysis General Direct Approach model for inputs X, outputs Y, price of inputs W, price of outputs P, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph (or Slack Based Measure (SBM)).\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\natol=1e-6: tolerance for DMU to be considered efficient.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitchange/#BenchmarkingEconomicEfficiency.effchange-Tuple{ProfitChangeDEAModel, Symbol}","page":"Profit Efficiency Change","title":"BenchmarkingEconomicEfficiency.effchange","text":"effchange(model::ProfitChangeDEAModel)\n\nReturn efficiency change of a profit change DEA model.\n\nOptional Arguments\n\ntype=Economic: type of efficiency change scores to return.\n\nType specification:\n\n:Economic: returns economic efficiency change of the model.\n:Technical: returns technical efficiency change.\n:Allocative: returns allocative efficiency change.\n\n\n\n\n\n","category":"method"},{"location":"cost/costholder/#Cost-Hölder-model","page":"Cost Hölder model","title":"Cost Hölder model","text":"The cost Hölder model is computed by solving an input-oriented Hölder distance function DEA model for the technical inefficiency.\n\nThe Hölder norms ell _h (hin left 1infty  right) are defined over a g-dimensional real normed space as follows:\n\nleft  right_hzto left z right_h=left beginmatrix\nleft( sumlimits_j=1^gleft z_j right^h right)^1h  textif hin left 1infty  right   \nundersetj=1gmathopmax left left z_j right right  textif h=infty   \nendmatrix right \t\n\nwhere z=left( z_1z_g right)in R^g. \n\nMirroring the options available when decomposing the Profit Hölder model, BenchmarkingEconomicEfficiency.jl calculates the technical inefficiency corresponding to the input-oriented Hölder distance functions under the same norms: unit (h=1), infinitum (h=infty), and h=2, corresponding to the Euclidean distance. For norm h=1 the Hölder distance functions are equivalent to the directional distance function presented in the Input-oriented Directional Distance Function with a specific directional vector. Pastor, Aparicio and Zofío (2022, Ch. 9) show that the  TI_WHddotolder(I)left( textbfx_otextbfy_o1 right) is calculated as the minimum of the values TI_DDF(I)left( textbfx_otextbfy_o left(01_left( m right)0 right) textbf0_N right) m=1M. These are input-oriented DDF models which are solved M times, each with a unit valued element g^-_om=1 for every m input, and the rest of the m-1 elements equal to zero, and assigning a zero valued output directional vector. Alternatively, for norm h=infty, the Hölder distance function is also equivalent to the oriented DDF model with an unitary input directional vector; i.e., TI_WHddotolder(I) left( textbfx_otextbfy_oinfty right) = TI_DDF(I)left( textbfx_otextbfy_o textbf1_M textbf0_N right). Calculating the technical inefficiency measure based on the Hölder distance under the Euclidean norm h=2 is complex because determining the shortest distance requires minimizing a convex function on the complement of a convex set. Pastor, Aparicio and Zofío (2022, Ch. 9) show that the Euclidean distance from firm (textbfx_otextbfy_o) to the weakly efficient frontier of Lleft( textbfy_o right) can be solved through quadratic optimization. In particular, by solving a bi-level linear program:\n\nbeginsplit\n TI_WHddotolder(I)left( mathbfx_omathbfy_o 2 right)= undersettextbfxtextbfypmblambdabeta pmbgamma mathopmin  sqrtsumlimits_m=1^Mleft( x_om-x_m right)^2  \n\t st quad sumlimits_j=1^Jlambda _jx_jmle x_m quad  m=1M  \n\t  quad quad sumlimits_j=1^Jlambda _jy_jnge y_n quad  n=1N  \n\t quad quad  sumlimits_j=1^Jlambda _j=1   \n\t quad quad beta =0 \n\t quad quad undersetbetapmbgammamathopmax beta    \n\t quad quad stsumlimits_j=1^Jgamma _jx_jmle x_m-beta quad m=1M  \n\t quad quad sumlimits_j=1^Jgamma _jy_jnge y_nquad  n=1N  \n\t quad quad sumlimits_j=1^Jgamma _j=1 \n\t quad quad lambda _jgamma _jge 0 quad j=1J  \n\t quad quad x_mge 0 quad m=1M  \nendsplit\n\nThe literature presents different ways of solving Bi-level Programing models, from exact methods to heuristics and metaheuristics. Here we use the Karush-Kuhn-Tucker conditions of the linear program embedded in the previous model, corresponding to undersetbeta pmbgammamathopmax beta and its associated contraints. Pastor, Aparicio and Zofío (2022, Ch. 9) show that, substituting this program with the corresponding set of complementary constrainst, one can solve the program through second order sets (SOS). Therefore, the final model to be solved is a quadratic programming problem with SOS conditions. BenchmarkingEconomicEfficiency.jl solves the Hölder  model associated to the Euclidean norm using the Gurobi optimizer. This requires adding it to Julia, which can be done under a free license for academic use only, or a paid commercial version. The optimizer can be downloaded from the company's website. A free academic license can be obtained here. Upon installation, add the package Gurobi.jl to Julia by running the following the commands: 'using Pkg', 'Pkg.add(\"Gurobi\")' and 'Pkg.build(\"Gurobi\")'.    \n\nOnce the technical inefficiency measures has been calculated, we recall the duality results that allow the decomposition of cost inefficiency into technical and allocative components: CI_WHddotolder(I)left( textbfx_otextbfy_o h tildetextbfw right) = TI_WHddotolder(I)left( textbfx_otextbfy_o h right) + AI_WHddotolder(I)left( textbfx_otextbfy_o h tildetextbfw right). For the euclidean norm, h=2, this results in the following expression: \n\nunderbracefracsumlimits_m=1^Mw_mx_om-Cleft( textbfy_o textbfw right)left w right_q_textNorm Cost Inefficiency=underbraceundersettextbfxlambda beta gamma mathopmin sqrtsumlimits_m=1^Mleft( x_om-x_m^* right)^2_textInput Technnical Inefficiency+underbraceAI_WHddotolder(I)left( textbfx_otextbfy_o htildetextbfw right)_textNorm Allocative Inefficiency ge 0\n\nwhere x^*_m is the solution to the technical inefficency problem. For the alternative norms h=1 and h=infty the decompositions are equivalent to the Input-oriented Directional Distance Function, where the directional vectors are set to the values previously commented. \n\nFrom the point of view of the satisfaction of properties, a critique associated with the Hölder distance functions is that they do not satisfy units' invariance because they are dependent on the units of measurement of inputs and outputs. This means that the comparison between the efficiency scores of different observations would change depending on the units of measurement chosen by the analyst. To solve this problem we can rely on the weighted version of the weakly efficient Hölder distance function (denoted as WW)–for details see Pastor, Aparicio and Zofío (2022, Ch. 9). Based on this distance function, we can decompose cost inefficiency into technical and allocative inefficiency terms that are units' invariant: CI_WWHddotolder(I)left( textbfx_otextbfy_o h tildetextbfw right) = TI_WWHddotolder(I)left( textbfx_otextbfy_oh right) + AI_WWHddotolder(I)left( textbfx_otextbfy_oh tildetextbfwright). For the Euclidean norm, h=2, this results in: \n\nunderbracefracsumlimits_m=1^Mw_mx_om-Cleft(textbfy_o textbfw right)left w right_q_textNorm Cost Inefficiency=underbraceundersettextbfxlambda beta gamma mathopmin sqrtsumlimits_m=1^Mleft(fracx_om-x_m^*x_omright)^2_textInput Technnical Inefficiency+underbraceAI_WWHddotolder(I)left( textbfx_otextbfy_o htildetextbfw right)_textNorm Allocative Inefficiency ge 0\n\nBenchmarking Economic Efficiency with Julia calculates both the unweighted and weighted versions of the cost Hölder model under the previous norms: ell _1,  ell _infty , and ell _2. The weighted version requires adding weight=true to the code–see below the documentation accompanying this function for the different options. \n\nReference\n\nChapter 9 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the Hölder L1 efficiency measure under variable returns to scale:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\nW = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\ncostholderl1 = deacostholder(X, Y, W, l = 1)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(costholderl1, :Economic)\n\nefficiency(costholderl1, :Technical)\n\nefficiency(costholderl1, :Allocative)","category":"section"},{"location":"cost/costholder/#deacostholder-Function-Documentation","page":"Cost Hölder model","title":"deacostholder Function Documentation","text":"","category":"section"},{"location":"cost/costholder/#BenchmarkingEconomicEfficiency.deacostholder","page":"Cost Hölder model","title":"BenchmarkingEconomicEfficiency.deacostholder","text":"deacostholder(X, Y, W; l)\n\nCompute cost efficiency using data envelopment analysis for inputs X, outputs Y and price of inputs W.\n\nHölder norm l specification\n\n1.\n2.\nInf.\n\nOptional Arguments\n\nweigt=false:  set to true for weighted (weakly) Hölder distance function.\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"revenue/revenuerddf/#Revenue-Reverse-Directional-Distance-Function-model","page":"Revenue Reverse Directional Distance Function model","title":"Revenue Reverse Directional Distance Function model","text":"The cost reverse directional distance function model is computed by solving an input-oriented Reverse DDF model for the technical inefficiency.\n\nAs their graph counterpart presented in the Profit Reverse Directional Distance Function model, the output-oriented RDDF transforms any additive measure of output technical inefficiency, EM(O), such as the Russell output measure, into a single scalar measure corresponding to an output-oriented DDF, beta_O. Therefore, given the set of J firms under study, F_J, and their projections on the frontier, denoted by hatF_J, the RDDF assigns a new DDF score to the original EM(O), while keeping the same projections hatF_J. We  denote this score by beta_RDDF(EM(O) F_J hatF_J). The advantage of the RDDF is that it relates the additive and multiplicative measures of technical inefficiency because the ouput-oriented DDFs is equivalent to the Farrell's output radial measures shown in the Revenue Radial model, i.e., beta_O^*=phi^*-1. \n\nTo calculate this distance functions for firm left( mathbfx_omathbfy_o right) we need to determine the directional vector mathbfg= (textbf0_Nmathbfg_x^+) connecting the firm to its output-oriented projection, left( textbfx_ohattextbfy_o right)in hatF_J. Afterwards we calculate the value of the RDDF(O). However, when calculating the new scores we need to differentiate between firms that are deemed technically efficient with EM(O)=0 and those that are technically inefficient. The measure EM(O) splits the sample into two disjoint subsets: F_E=left left( x_jy_j right)in F_JTI_EM(O)left( x_jy_j right)=0 right and F_Jsim E=left left( x_jy_j right)in F_JTI_EM(O)left( x_jy_j right)0 right. Then, for the output orientation we define the directional vector joining the firm under evaluation and its projection as follows   \n\nIf left( textbfx_jtextbfy_j right)in F_Jsim E, define \n\nleft(textbfg^-_textbfx_jtextbfg^+_textbfy_j right)= left( textbf0_M  fracmathbfhaty_j-mathbfy_jTI_EMleft( G right)left( mathbfx_jmathbfy_j right) right)    and  beta_RDDF(O)^*=TI_EM(O)left( textbfx_jtextbfy_j right)0\n\nIf left( textbfx_jtextbfy_j right)in F_E, define \n\nbeta _RDDF(I)^*=TI_EMleft( O right)left( textbfx_jtextbfy_j right)=0   and  left( textbf0_N textbfg^+_textbfy_j right)= left(textbf0_Mvectextbfk_jN right)in mathbbR_++^M+N\n\nwhere vectextbfk_jNin mathbbR_++^N is a vector whose units of measurement are identical to those of the firm under evaluation left( textbfx_jtextbfy_j right)in F_E–making revenue inefficiency units' invariant. For consistency we search for a value that yields a normalization factor whose value is equal to that associated to the underlying efficiency measure, i.e, sumlimits_n=1^Np_n^k_jn^+= NF_EM(O). This choice of vectextbfk_jN is numerically relevant because it makes the values of normalized cost inefficiency based on the RDDF and the original EM(O) equivalent, and therefore their normalized allocative efficiencies can be compared to each other–their technical inefficiency values being null. \n\nWe now present the expressions corresponding to the revenue inefficiency measure and its decomposition associated with the RDDF. This results in RI_RDDFleft( EMleft( O right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_y^+tildetextbfp right) = TI_RDDFleft( EMleft( O right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_y^+ right) + AI_RDDFleft( EMleft( O right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_y^+ tildetextbfp right). Hence we obtain the following expression: \n\nunderbracefracR left( mathbfx_omathbfp right) - sumlimits_n=1^Np_ny_om sumlimits_n=1^Np_ng^-_on_textNorm Revenue Inefficiency=underbracebeta _RDDFleft( EMleft( O right)F_JhatF_J right)^*_textOutput Technical Inefficiency+underbraceAI_RDDFleft( EMleft( O right)F_JhatF_J right)left( textbfx_otextbfy_otextbfg_textbfy_o^+ tildetextbfp right)_textNorm Allocative Inefficiency ge 0\n\nwhere the efficiency scores beta _RDDFleft( EMleft( O right)F_JhatF_J right)^* for technically inefficient firms is obtained by solving the Output-oriented Directional Distance Function model with the corresponding directional vectors. . \n\nBenchmarkingEconomicEfficiency.jl with Julia offers the possibility of decomposing revenue inefficiency based on the RDDF considering as original measure the Russell output-oriented model. \n\nReference\n\nChapter 12 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the revenue efficiency Reverse directional distance function measure for the Russell technical inefficiency:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5];\n\nP = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\nrevenuerddf = dearevenuerddf(X, Y, P, :ERG)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(revenuerddf, :Economic)\n\nefficiency(revenuerddf, :Technical)\n\nefficiency(revenuerddf, :Allocative)","category":"section"},{"location":"revenue/revenuerddf/#dearevenuerddf-Function-Documentation","page":"Revenue Reverse Directional Distance Function model","title":"dearevenuerddf Function Documentation","text":"","category":"section"},{"location":"revenue/revenuerddf/#BenchmarkingEconomicEfficiency.dearevenuerddf","page":"Revenue Reverse Directional Distance Function model","title":"BenchmarkingEconomicEfficiency.dearevenuerddf","text":"dearevenuerddf(X, Y, P, measure)\n\nCompute profit efficiency using data envelopment analysis Reverse DDF model for inputs X, outputs Y, price of outputs P, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph Slack Based Measure.\n\nOptional Arguments\n\nrts=:VRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"cost/costefficiency/#Cost-(In)Efficiency-measurement","page":"Cost (In)Efficiency measurement","title":"Cost (In)Efficiency measurement","text":"Cost efficiency allows studying the economic performance of firms as cost minimizers; i.e. their ability to minimize the cost of producing a given level of output given input prices. Cost efficiency (inefficency) can be measured and decomposed multiplicatively (additively), depending on the (in)efficiency measure that is employed. The multiplicative approach is most well-known as it corresponds to Farrell's original proposal. For this reason we present the models available starting with this approach, and then follow with the many additive decompositions that have been proposed in the literature, based on the different input-oriented inefficiency measures, denoted by EM(I), that can be also found in the profit and revenue approaches. \n\nAs before, measuring economic efficiency requires the definition of the optimal economic goal to be achieved by the firms. In this case, the minimum cost of producing an output level textbfy, represented by the input set L(textbfy_o). The cost function is defined as follows: \n\nC(mathbfymathbfw)=undersetmathbfxmathoptextminleft mathbfwcdot mathbfx   mathbfx ge Xmathbflambdamathbfy_o leqslant\nYmathbflambda mathbfmathbfelambda=1 lambda  ge mathbf0 right mathbfwin mathbbR_++^Mmathbfy_oge 0_N\n\nMinimum cost along with the optimal input quantities can be calculated through DEA by solving the following model:  \n\nbeginsplit\n Cleft( mathbfy_omathbfw right)=undersetmathbfxpmblambda mathopmin  sumnolimits_m=1^Mw_mx_m  \n textstextttextquad sumlimits_j=1^Jlambda _j^x_jm^le  x_m m=1Mtext   \n quad quad sumnolimits_j=1^Jlambda _j^y_jn^ge y_on^ n=1Ntext   \n quad quad sumnolimits_j=1^Jlambda _j^=1  \n quad quad lambda ge 0   \nendsplit\n\nMultiplicative decomposition cost efficiency\n\nFor firm left( textbfx_o^textbfy_o^ right), cost efficiency defines multiplicatively as the ratio of minimum cost to observed cost, i.e., \n\nmathitCE(textbfx_otextbfy_otextbfw)= Cleft(mathbfy_omathbfwright)C_o=Cleft(mathbfy_omathbfwright)mathbfwcdot mathbfx_o=Cleft(mathbfy_omathbfwright)sumlimits_m=1^Mw_mx_om le 1\n\nTherefore if mathitCE(textbfx_otextbfy_otextbfw) = 1 the firm minimizes cost, and the smaller the value of the cost efficiency, the greater the cost excess of the firm with respect to the economic benchmark. \n\nBased on the duality between the cost function and the radial input measure, it is possible  to decompose cost efficiency multiplicatively into a measure of technical efficiency and a residual measure of allocative inefficiency. This method is presented in the following section Cost Radial model.  \n\nAdditive decompositions of cost inefficiency\n\nCost inefficiency is defined additively as the difference between observed cost and minimum cost: \n\nCI(textbfx_otextbfy_otextbfw) = C_o-Cleft(mathbfy_omathbfwright) = mathbfw cdot x_o-Cleft(mathbfy_omathbfwright) = sumnolimits_m=1^Mw_mx_om -Cleft(mathbfy_omathbfwright) ge 0\n\nTherefore if mathitCI(textbfx_otextbfy_otextbfw) = 0 the firm minimizes cost, and the greater the value of the cost inefficiency, the greater the cost excess of the firm with respect to the economic benchmark. \n\nFollowing the literature the decomposition of cost inefficiency can be performed based on different input-oriented technical inefficiency measures. Regardless the particular ineffiency measure, EM(I), cost inefficiency is decomposed into an input technical inefficiency measure, generally denoted by TI_EM(I)(textbfx_o textbfy_o), and an allocative term. Regarding efficiency measurement, if a firm is technically efficient, the efficiency score is null, i.e, EM(I) = 0. On the contrary, if the inefficiency score is positive, the firm is technically inefficient.  After calculating the input-oriented technical inefficiency, and based on the duality between the cost and each technical inefficiency measure, we can establish two Fenchel-Mahler inequalities by which normalized cost inefficiency: CI(textbfx_otextbfy_o tildetextbfw) =mathitCI(textbfx_otextbfy_otextbfw)NF_EM(I), is greater or equal in value to the technical efficiency measure, i.e., mathitCI(textbfx_otextbfy_otextbfw)NF_EM(I) ge TI_EM(I)(textbfx_o textbfy_o), CI(textbfx_otextbfy_o tildetextbfw).\n\nThe divisor NF_EM(I) is a normalizing scalar derived from the duality relationship. Afterwards, a scalar representing normalized allocative inefficiency is obtained as a residual by closing the inequality. Cost allocative inefficiency measures the cost excess that can be attributed to the fact that firm (or its technically projected benchmark) does not demand the optimal input quantities. \n\nNormalized cost inefficiency can be decomposed then as follows: \n\nunderbracefrac sumlimits_m=1^Mw_mx_om - C left( mathbfy_omathbfw right)NF_EM(I)_textNormtext Cost Inefficiency= quad =underbraceTI_EM(I)(textbfx_o textbfy_o)_textInput Technical Inefficiency+ underbraceAI_EM(I)left( mathbfx_omathbfy_omathbftildewright)_textNormtext Allocative Inefficiency ge 0    \n\nThe following functions available in BenchmarkingEconomicEfficiency.jl present alternative decompositions of cost inefficiency based on the most relevant technical inefficiency measures proposed in the literature. As for the decompositions, being normalized, they all satisfy the property of commensurability (or units' invariance), and therefore they are independent of the units of measurement of quantities and prices. Additionally, each of these measures results in a particular decomposition whose pros and cons in terms of a series of properties are inherited from those of the underlying technical inefficiency measure: TI_EM(I)(textbfx_o textbfy_o). Pastor, Aparicio and Zofío (2022, Chap. 14) discuss the properties of the different decompositions. \n\nReference\n\nChapter 2 and 14 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. ","category":"section"},{"location":"profit/profitenhancedrussell/#Profit-Enhanced-Russell-Graph-Slack-Based-Measure","page":"Profit Enhanced Russell Graph Slack Based Measure","title":"Profit Enhanced Russell Graph Slack Based Measure","text":"The profit enhanced Russell graph-slack based measure is computed by solving an enhanced Russell graph-slack based measure model for the technical efficiency.\n\nThe enhanced Russell graph measure ERG (or slack-based measure) was designed as a new global efficiency measure to overcome the computational difficulties of the  Profit Russell model. The novelty lays on the definition of a non-radial model that accounts for both inputs and outputs (graph or non-oriented) as the Russell proposal, but that is easier to compute through linear programming–as opposed to the standard Russell model. The ERG=SBM measure is formulated resorting to the same variables as the Russell graph measure: the 'thetas' (theta's) for the proportional individual reduction of each of the M inputs, the 'phys' (phi's) for the proportional individual output increase of each of the N outputs, and the `lambdas' (lambda's) defining the reference hyperplanes from the obeservations that constitute the production frontier. The technical efficiency model corresponds to: \n\nbeginsplit\n\tTE_ERG=SBM(G)left( x_oy_o right) =   undersetpmbtheta  pmbphi pmblambda mathopmin   fracfrac1Msumlimits_m=1^Mtheta _mfrac1Nsumlimits_n=1^Nphi _n \n\t st quad sumlimits_j=1^Jlambda _jx_mj=theta _mx_om quad m=1M   \n\t quad quad sumlimits_j=1^Jlambda _jy_nj=phi _ny_on quad n=1N \n\t quad quad sumlimits_j=1^Jlambda _j=1 \n\t quad quad theta _mle 1 quad m=1M \n\t quad quad phi _nge 1 quad n=1N   \n\t quad quad lambda _jge 0 quad j=1J  \nendsplit\n\nComparing this model with that defining the Russell graph measure the only difference is the objective function, originally formulated as frac1M+Nleft( sumlimits_m=1^Mtheta _m+sumlimits_n=1^Nfrac1phi _n right). From the perspective of finding the solution of this model this difference is relevant because we have replaced the original nonlinear objective function with a linear fractional objective function, i.e., a fraction of two linear expressions, that is easier to solve.\n\nFor this purpose, after performing a change of variables that formulates the model in terms of slacks instead of the multiplicative reduction of each input and increase of each output, and introducing a variable beta corresponding to the inverse of the denominator of the resulting objective function–see Pastor, Aparicio and Zofío (2022, Ch. 7)–we obtain the final linear program that calculates the value of the ERG=SMB measure of technical efficiency:   \n\nbeginsplit\n \t TE_ERG=SBM(G)left( textbfx_otextbfy_o right)=  undersettextbft_^-textbft_^+pmbmu pmbbeta mathopmin   beta -frac1Msumlimits_m=1^Mfract_m^-x_om   \n \t\t st quad beta +frac1Nsumlimits_n=1^Nfract_n^+y_on=1  \n \t\t quad quad sumlimits_j=1^Jmu _jx_jm=beta x_om-t_m^-  quad m=1M   \n \t\t quad quad sumlimits_j=1^Jmu _jy_jn=beta y_on+t_n^+  quad n=1N   \n \t\t quad quad sumlimits_j=1^Jmu _j=beta   \n \t\t quad quad beta ge 0  \n \t\t quad quad t_m^-ge 0t_n^+ge 0 quad forall mn  \n \t\t quad quadmu _jge 0 quad j=1J   \nendsplit\n\nFrom the solution to this program we can recover the following measure of technical inefficiency: \n\nbeginsplit\n\t TI_ERG=SBM(G)left( textbfx_otextbfy_o right)=1-TE_ERG=SBM(G)left( textbfx_otextbfy_o right)=   \n\t quad 1-frac1-frac1Msumlimits_m=1^Mfracs_m^-*x_om1+frac1Nsumlimits_n=1^Nfracs_n^+*y_on^=fracfrac1Nsumlimits_n=1^Nfracs_n^+*y_on^+frac1Msumlimits_m=1^Mfracs_m^-*x_om1+frac1Nsumlimits_n=1^Nfracs_n^+*y_no^   \nendsplit\n\nResorting to the duality between this expression and the profit function we can establish the associated decomposition of profit inefficiency:  Pi I_ERG=SBM(G)^left( textbfx_otextbfy_otildetextbfwtildetextbfp right)=TI_ERG=SBM(G)left( textbfx_otextbftextbfy_o right)+AI_ERG=SBM(G)left( textbfx_otextbfy_otildetextbfwtildetextbfp right); i.e.,\t\t   \n\nbeginsplit\n underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)delta _left( textbfx_otextbfy_otextbfptextbfw right)left( 1+frac1Nsumlimits_n=1^Nfracs_n^+*y_on^ right)_textNormtext textProfit textInefficency=   \n quad =underbraceleft( fracfrac1Nsumlimits_n=1^Nfracs_n^+*y_on^+frac1Msumlimits_m=1^Mfracs_m^-*x_om^left( 1+frac1Nsumlimits_n=1^Nfracs_n^+*y_on^ right) right)_textGraph Techncial Inefficency+underbraceAI_ERG=SBM(G)left( mathbfx_omathbfy_otildetextbfptildetextbfw right)_textNormtext textAllocative textInefficencyge 0 \nendsplit\n\nwhere delta _left( textbfx_otextbfy_otextbfptextbfw right)=min left Np_ny_on^n=1NMw_mx_om^m=1M right in the normalization factor of the ERG=SBM. \n\nReference\n\nChapter 7 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the profit efficiency Enhanced Russell Graph Slack Based measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofiterg = deaprofiterg(X, Y, W, P)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profiterg, :Economic)\n\nefficiency(profiterg, :Technical)\n\nefficiency(profiterg, :Allocative)","category":"section"},{"location":"profit/profitenhancedrussell/#deaprofiterg-Function-Documentation","page":"Profit Enhanced Russell Graph Slack Based Measure","title":"deaprofiterg Function Documentation","text":"","category":"section"},{"location":"profit/profitenhancedrussell/#BenchmarkingEconomicEfficiency.deaprofiterg","page":"Profit Enhanced Russell Graph Slack Based Measure","title":"BenchmarkingEconomicEfficiency.deaprofiterg","text":"deaprofiterg(X, Y, W, P)\n\nCompute profit efficiency using data envelopment analysis Enhanced Russell Graph Slack Based Measure model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"cost/costrussell/#Cost-Russell-model","page":"Cost Russell model","title":"Cost Russell model","text":"The cost Russell model is computed by solving an input-oriented Russell DEA model for the technical efficiency.\n\nTaking the Russell measure as reference, Pastor, Aparicio and Zofío (2022, Ch. 5) present the Fenchel-Mahler inequality obtained from the dual correspondence between the cost function and this measure of input technical inefficiency. The Russell input-oriented measure quantifying the technical inefficiency of a firm can be calculated through DEA methods by solving the following program:   \n\nbeginsplit\n TE_RM(I)left( textbfx_otextbfy_o right)= undersetbeginsmallmatrix\tpmbtheta  pmblambda endsmallmatrixmathopmin  frac1M sumlimits_m=1^Mtheta _m  \n st quad sumlimits_j=1^Jlambda _jx_jm=theta _mx_om quad  m=1M  \n quad quad sumlimits_j=1^Jlambda _jy_jn=y_on quad  n=1N   \n quad quad sumlimits_j=1^Jlambda _j=1   \n quad quad theta _mle 1 quad  m=1M   \n quad quad lambda _jge 0 quad  j=1J   \nendsplit\n\nIn this program, theta^*_m evaluates the relative proportional reduction of input m m=1M. The objective function averages these proportional rates of input contraction. Contrary to the Russell graph DEA model, this program is linear and therefore easy to calculate through the simplex method. \n\nConsidering TE_RM(I)(textbfx_otextbfy_o) we can define is technical inefficiency counterparts as TI_RM(I)( textbfx_otextbfy_o)=1-TE_RM(I) (textbfx_otextbfy_o). It is then possible to decompose cost inefficiency into technical and allocative components: CI_RMleft( I right)left( textbfx_otextbfy_otildetextbfw right) = TI_RMleft( I right)left( textbfx_otextbfy_o right) + AI_RMleft( I right)left( textbfx_otextbfy_o tildetextbfw right). That is  \n\nunderbracefracsumlimits_m=1^Mw_mx_om - C left( mathbfy_omathbfw right) M min left w_1x_o1w_Mx_oMright_textNorm Cost Inefficiency = underbrace1-frac1Msumlimits_m=1^Mtheta _m^* _textInput Technical Inefficiency+underbraceAI_RMleft( I right)left( textbfx_otextbfy_otildetextbfw right)_textNorm Allocative Inefficiencyge 0  \n\nReference\n\nChapter 5 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the cost efficiency Russell measure under variable returns to scale:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\nW = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\ncostrussell = deacostrussell(X, Y, W)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(costrussell, :Economic)\n\nefficiency(costrussell, :Technical)\n\nefficiency(costrussell, :Allocative)","category":"section"},{"location":"cost/costrussell/#deacostrussell-Function-Documentation","page":"Cost Russell model","title":"deacostrussell Function Documentation","text":"","category":"section"},{"location":"cost/costrussell/#BenchmarkingEconomicEfficiency.deacostrussell","page":"Cost Russell model","title":"BenchmarkingEconomicEfficiency.deacostrussell","text":"deacostrussell(X, Y, W)\n\nCompute cost efficiency using Russell data envelopment analysis for inputs X, outputs Y and price of inputs W.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitddf/#Profit-Directional-Distance-Function-model","page":"Profit Directional Distance Function model","title":"Profit Directional Distance Function model","text":"The profit directional model is computed by solving a Directional Distance Function DEA Model for the technical inefficiency.\n\nThe directional distance function DDF, projects firm left( mathbfx_omathbfy_o right) to the production frontier  in the pre-assigned direction mathbfg= left(mathbfg_x^-mathbfg^+_y right)neqmathbf0_M+N, mathbfg^-_xmathbbin R^M and mathbfg^+_ymathbbin R^N. Inputs and outputs are respectively reduced and increased according to the scalar beta, identifying as reference projection (hatmathbfx_ohatmathbfy_o)=left( textbfx_o-betatextbfg_textbfx^-textbfy_o+betatextbfg_textbfy^+ right). Therefore the directional distance functions define as follows:\n\nTI_DDF(G)left( textbfx_otextbfy_o textbfg_textbfx^- textbfg_textbfy^+ right)=max left beta left( textbfx_o-betatextbfg_textbfx^-textbfy_o+betatextbfg_textbfy^+ right) in T beta ge 0 right\n\nThe DDF is calculated through the following DEA linear program:\n\nbeginsplit\n\t TI_DDF(G)left( mathbfx_omathbfy_o right)=undersetbeta _lambda mathoptextmaxbeta    \n\t st  quad  sumlimits_jin J^lambda _jx_jmle x_om-beta g_x_m^-m=1M   \n\t quad quad sumlimits_jin J^lambda _jy_jnge y_on+beta g_y_n^+n=1N   \n\t quad quad  sumlimits_jin J^lambda _j=1   \n\t quad quad lambda _jge 0jin J\nendsplit \n\nA firm is technically efficient if its optimal solution is beta^*=0. Therefore if beta^*0, the observation is inefficient. The decomposition of the so-called Nerlovian economic inefficiency based on the directional distance function:  PiI_DDFleft( G right)left( textbfx_otextbfy_omathbfg_x^-mathbfg^+_ytildetextbfw tildetextbfp right) = TI_DDDFleft( G right)left( textbfx_otextbfy_omathbfg_x^-mathbfg^+_y right) + AI_DDFleft( G right)left( textbfx_otextbfy_omathbfg_x^-mathbfg^+_y tildetextbfw tildetextbfp right). This results in the following expression: \n\nbeginsplit\n   underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)sumlimits_m=1^Mw_m^g_om^-+sumlimits_n=1^Np_n^y_on^+_textNormtext Profit Inefficiency=  \n   quad =underbracebeta _DDF(G)^*_textGraph Technical Inefficiency+ underbraceAI_DDF(G)left( mathbfx_omathbfy_omathbfg_mathbfx^mathbf-mathbfg_mathbfy^+mathbftildewmathbftildep right)_textNormtext Allocative Inefficiency ge 0  \nendsplit  \n\nReference\n\nChapter 8 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the profit efficiency measure considering a choice of directional vector that returns profit inefficiency in monetary terms:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitddf = deaprofit(X, Y, W, P, Gx = :Monetary, Gy = :Monetary)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitddf, :Economic)\n\nefficiency(profitddf, :Technical)\n\nefficiency(profitddf, :Allocative)","category":"section"},{"location":"profit/profitddf/#deaprofit-Function-Documentation","page":"Profit Directional Distance Function model","title":"deaprofit Function Documentation","text":"","category":"section"},{"location":"profit/profitddf/#DataEnvelopmentAnalysis.deaprofit","page":"Profit Directional Distance Function model","title":"DataEnvelopmentAnalysis.deaprofit","text":"deaprofit(X, Y, W, P; Gx, Gy)\n\nCompute profit efficiency using data envelopment analysis model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n:Monetary: use direction so that profit inefficiency is expressed in monetary values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"cost/costrddf/#Cost-Reverse-Directional-Distance-Function-model","page":"Cost Reverse Directional Distance Function model","title":"Cost Reverse Directional Distance Function model","text":"The cost reverse directional distance function model is computed by solving an input-oriented Reverse DDF model for the technical inefficiency.\n\nAs their graph counterpart presented in the Profit Reverse Directional Distance Function model, the input-oriented RDDF transforms any additive measure of input technical inefficiency, EM(I), such as the Russell input measure, into a single scalar measure corresponding to an input-oriented DDF, beta_I. Therefore, given the set of J firms under study, F_J, and their projections on the frontier, denoted by hatF_J, the RDDF assigns a new DDF score to the original EM(I), while keeping the same projections hatF_J. We  denote this score by beta_RDDF(EM(I) F_J hatF_J).  The advantage of the input-oriented RDDF is that it relates the additive and multiplicative measures of technical inefficiency because the input-oriented DDFs is equivalent to Farrell's input radial measure shown in the Cost Radial model, i.e., beta_I^*=1-theta^*.\n\nTo calculate this distance function for firm left( mathbfx_omathbfy_o right) we need to determine the directional vector mathbfg= (mathbfg_x^-textbf0_M) connecting the firm to its input-oriented  projection, left( hattextbfx_otextbfy_o right)in hatF_J. Afterwards we calculate the value of the RDDF(I). However, when calculating the new scores we need to differentiate between firms that are deemed technically efficient with EM(I)=0 and those that are technically inefficient. The measure EM(I) splits the sample of firms F_J into two disjoint subsets: F_E=left left( x_jy_j right)in F_JTI_EM(I)left( x_jy_j right)=0 right and F_Jsim E=left left( x_jy_j right)in F_JTI_EM(I)left( x_jy_j right)0 right. Then, for the input orientation we define the directional vector joining the firm under evaluation and its projection as follows   \n\nIf left( textbfx_jtextbfy_j right)in F_Jsim E, define \n\nleft(textbfg^-_textbfx_jtextbfg^+_textbfy_j right)=left( frachattextbfx_j -textbfx_jTI_EMleft( I right)left( textbfx_jtextbfy_j right)textbf0_M right)   and  beta_RDDF(I)^*=TI_EM(I)left( textbfx_jtextbfy_j right)0\n\nIf left( textbfx_jtextbfy_j right)in F_E, define \n\nbeta _RDDF(I)^*=TI_EMleft( I right)left( textbfx_jtextbfy^+_j right)=0   and  left( textbfg^-_textbfx_j textbf0_M right)= left(vectextbfk_jMtextbf0_N right)in mathbbR_++^M+N\n\nwhere vectextbfk_jMin mathbbR_++^M is a vector whose units of measurement are identical to those of the firm under evaluation left( textbfx_jtextbfy_j right)in F_E–making cost inefficiency units' invariant. For consistency we search for a value that yields a normalization factor whose value is equal to that associated to the underlying efficiency measure, i.e, sumlimits_m=1^Mw_m^k_jm^-= NF_EM(I). This choice of vectextbfk_jM is numerically relevant because it makes the values of normalized cost inefficiency based on the RDDF and the original EM(I) equivalent, and therefore their normalized allocative efficiencies can be compared to each other–their technical inefficiency values being null. \n\nWe now present the expression corresponding to the cost inefficiency measure and its decomposition associated with the RDDF. This results in CI_RDDFleft( EMleft( I right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_x^-tildetextbfw right) = TI_RDDFleft( EMleft( I right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_x^- right) + AI_RDDFleft( EMleft( I right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_x^- tildetextbfw right). Hence we obtain the following expressions: \n\nunderbracefracsumlimits_m=1^Mw_mx_om-Cleft( textbfwtextbfy_o right)sumlimits_m=1^Mw_mg^-_om_textNorm Cost Inefficiency=underbracebeta _RDDFleft( EMleft( I right)F_JhatF_J right)^*_textInput Technical Inefficiency+underbraceAI_RDDFleft( EMleft( I right)F_JhatF_J right)left( textbfx_otextbfy_otextbfg_textbfx_o^- tildetextbfw right)_textNorm Allocative Inefficiencyge 0\n\nwhere the efficiency score beta _RDDFleft( EMleft( I right)F_JhatF_J right)^* for technically inefficient firms is obtained by solving the Input-oriented Directional Distance Function model with the corresponding directional vector. \n\nBenchmarkingEconomicEfficiency.jl offers the possibility of decomposing cost inefficiency based on the RDDF considering as original measure the Russell input-oriented model. \n\nReference\n\nChapter 12 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the cost efficiency Reverse directional distance function measure for the Russell technical inefficiency:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\nW = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\ncostrddf = deacostrddf(X, Y, W, :ERG)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(costrddf, :Economic)\n\nefficiency(costrddf, :Technical)\n\nefficiency(costrddf, :Allocative)","category":"section"},{"location":"cost/costrddf/#deacostrddf-Function-Documentation","page":"Cost Reverse Directional Distance Function model","title":"deacostrddf Function Documentation","text":"","category":"section"},{"location":"cost/costrddf/#BenchmarkingEconomicEfficiency.deacostrddf","page":"Cost Reverse Directional Distance Function model","title":"BenchmarkingEconomicEfficiency.deacostrddf","text":"deacostrddf(X, Y, W, measure)\n\nCompute profit efficiency using data envelopment analysis Reverse DDF model for inputs X, outputs Y, price of inputs W, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph Slack Based Measure.\n\nOptional Arguments\n\nrts=:VRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"optimizer/#Configuring-the-optimizer","page":"Configuring Optimizer","title":"Configuring the optimizer","text":"BenchmarkingEconomicEfficiency.jl will use a default optimizer/solver for each DEA model, as shown in the next table.\n\nModel Function Specific Options Problem type Default Optimizer\nProfit Russell deaprofitrussell  NLP Ipopt\nProfit Additive deaprofitadd  LP GLPK\nProfit ERG=SBM deaprofiterg  LP GLPK\nProfit DDF deaprofit  LP GLPK\nProfit Hölder deaprofitholder  LP GLPK\nProfit MDDF deaprofitmddf  LP GLPK\nProfit Reverse DDF deaprofitrddf :ERG LP GLPK\nProfit Reverse DDF deaprofitrddf :MDDF LP GLPK\nProfit GDA deaprofitgda  LP GLPK\nProfitability GDF deaprofitability  NLP Ipopt\nCost Radial deacost  LP GLPK\nCost Russell deacostrussell  LP GLPK\nCost Additive deacostadd  LP GLPK\nCost DDF deacostddf  LP GLPK\nCost Hölder deacostholder  LP GLPK\nCost Reverse DDF deacostrddf  LP GLPK\nCost GDA deacostgda  LP GLPK\nRevenue Radial dearevenue  LP GLPK\nRevenue Russell dearevenuerussell  LP GLPK\nRevenue Additive dearevenueadd  LP GLPK\nRevenue DDF dearevenueddf  LP GLPK\nRevenue Hölder dearevenueholder  LP GLPK\nRevenue Reverse DDF dearevenuerddf  LP GLPK\nRevenue GDA dearevenuegda  LP GLPK\n\nWhere:\n\nLP = Linear programming.\nNLP = Nonlinear programming.\n\nModels can be solved using a different optimizer by passing a DEAOptimizer object to the optimizer optional argument. For instruction, see the documentation on the DataEnvelopmentAnalysis package.","category":"section"},{"location":"profit/profitrddf/#Profit-Reverse-Directional-Distance-Function-model","page":"Profit Reverse Directional Distance Function model","title":"Profit Reverse Directional Distance Function model","text":"The profit reverse directional distance function model is computed by solving a graph Reverse DDF model for the technical inefficiency.\n\nThe advantage of decomposing profit inefficiency with the RDDF is that it relates existing additive measures of technical inefficiency to the popular directional distance function, DDF. The RDDF is capable of transforming any additive measure of graph technical inefficiency, EM(G), such as the Enhanced Russell Graph  or the Modified Directional Distance Function, into a single scalar measure corresponding to a standard DDF. Therefore, given the set of J firms under study, F_J, and their projections on the frontier, denoted by hatF_J, the RDDF assigns a new DDF score beta to the original EM(G), compatible with the projections hatF_J. \n\nTo calculate the RDDFleft( EMleft( G right)F_JhatF_J right) for firm left( mathbfx_omathbfy_o right) we need to determine the directional vector mathbfg= (mathbfg_x^-textbfg_textbfy^+) connecting the firm to its projection, left( hattextbfx_ohattextbfy_o right)in hatF_J. Afterwards we calculate the value of the RDDF. However, when calculating the new RDDF scores we need to differentiate between firms that are deemed technically efficient under EM(G) and those that are technically inefficient. The measure EM(G) splits the sample of firms F_J into two disjoint subsets: F_E=left left( textbfx_jtextbfy_j right)in F_JTI_EM(G)left( textbfx_jtextbfy_j right)=0 right and F_Jsim E=left left( textbfx_jtextbfy_j right)in F_JTI_EM(G)left( xtextbf_jtextbfy_j right)0 right. Then, \n\nIf left( textbfx_jtextbfy_j right)in F_Jsim E, define \n\nleft( textbfg_textbfx_jtextbfg_textbfy_j right)= left( frac hattextbfx_j-textbfx_j TI_EMleft( G right)left( textbfx_jtextbfy_j right)  fracmathbfhaty_j-mathbfy_jTI_EMleft( G right)left( mathbfx_jmathbfy_j right) right)  and   beta_RDDF(G)^*=TI_EM(G)left( textbfx_jtextbfy_j right)0\n\nIf left( textbfx_jtextbfy_j right)in F_E, define \n\nbeta _j^*=TI_EMleft( I right)left( textbfx_jtextbfy_j right)=0  and   left( textbfg_textbfx_jtextbfg_textbfy_j right)= left( vectextbfk_jMvectextbfk_jN right)in mathbbR_++^M+N\n\nwhere vectextbfk_jMin mathbbR_++^M and vectextbfk_jNin mathbbR_++^N are vectors whose M and N components have the same units of measuremenet that left( textbfx_jtextbfy_j right)–making profit inefficiency units' invariant. For consistency we search for a combination that yields a normalization factor for profit inefficiency whose value is equal to that associated to the underlying efficiency measure, i.e, sumlimits_m=1^Mw_m^k_om^-+sumlimits_n=1^Np_n^k_on^+ = NF_EM(G). This choice of textbfk_j  is numerically relevant because it makes the values of the normalized profit inefficiency based on the RDDF and that of the original EM(G) equal, and therefore their normalized allocative efficiencies can be compared to each other–-their technical inefficiency values being null.    \n\nWe now present the expression corresponding to the profit inefficiency measure and its decomposition associated with the RDDF. From the Profit Directional Distance Function model , we know how to gauge and decompose profit inefficiency through the directional distance function. This results in PiI_RDDFleft( EMleft( G right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_x^- mathbfg_y^+ tildetextbfw tildetextbfp  right) = TI_RDDFleft( EMleft( I right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_x^-mathbfg_y^+ right) + AI_RDDFleft( EMleft( G right)F_JhatF_J right)left( textbfx_otextbfy_omathbfg_x^-mathbfg_y^+ tildetextbfw tildetextbfp right); i.e., \n\nbeginsplit\n underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)sumlimits_m=1^Mw_m^g_om^-+sumlimits_n=1^Np_n^g_on^+_textNormtext Profit Inefficiency=  \n quad =underbracebeta _RDDFleft( EMleft( G right)F_JhatF_J right)^*_textGraph Technical Inefficiency+ underbraceAI_RDDFleft( EMleft( G right)F_JhatF_J right)left( mathbfx_omathbfy_omathbfg_mathbfx^mathbf-mathbfg_mathbfy^+mathbftildewmathbftildep right)_textNormtext Allocative Inefficiency ge 0  \nendsplit \n\nwhere the efficiency score beta _RDDFleft( EMleft( G right)F_JhatF_J right)^* for technically inefficient firms is obtained by solving the DDF program with the associated directional vectors.  \n\nBenchmarkingEconomicEfficiency.jl offers the possibility of decomposing profit inefficiency based on the RDDF considering as original EM(G) measure the enhanced Russell graph measure. \n\nReference\n\nChapter 12 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the profit efficiency Reverse directional distance function measure for the Enhanced Russell Graph associated efficiency measure under variable returns to scale:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitrddf = deaprofitrddf(X, Y, W, P, :ERG)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitrddf, :Economic)\n\nefficiency(profitrddf, :Technical)\n\nefficiency(profitrddf, :Allocative)","category":"section"},{"location":"profit/profitrddf/#deaprofitrddf-Function-Documentation","page":"Profit Reverse Directional Distance Function model","title":"deaprofitrddf Function Documentation","text":"","category":"section"},{"location":"profit/profitrddf/#BenchmarkingEconomicEfficiency.deaprofitrddf","page":"Profit Reverse Directional Distance Function model","title":"BenchmarkingEconomicEfficiency.deaprofitrddf","text":"deaprofitrddf(X, Y, W, P, measure)\n\nCompute profit efficiency using data envelopment analysis Reverse DDF model for inputs X, outputs Y, price of inputs W, price of outputs P, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph Slack Based Measure.\n:MDDF: Modified Directional Distance Function.\n\nDirection specification:\n\nFor the Modified Directional Distance Function, the directions Gx and Gy can be one of the following symbols.\n\n:Observed: use observed values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\natol=1e-6: tolerance for DMU to be considered efficient.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"revenue/revenueadditive/#Revenue-Additive-model","page":"Revenue Additive model","title":"Revenue Additive model","text":"The revenue additive model is computed by solving an additive DEA model for the technical inefficiency.\n\nThe decomposition of revenue inefficiency based on the weighted additive distance function measures output-oriented  technical inefficiency based solely on output shortfalls, given by the following slack variables: mathbfs^+mathbbin R^N. When the firm under evaluation (mathbfx_o, mathbfy_o) belongs to the production technology (as it is the case in cross-sectional studies), the DEA graph WADF model for measuring technical inefficiency is equivalent to the standard weighted additive model, which corresponds to the following DEA program:\n\nbeginsplit\n TI_WADFtext(Otext)left( textbfx_otextbfy_orho ^+ right)= undersetpmbs^+pmblambda  mathoptextmax sumlimits_n=1^Nrho _n^+s_n^+   \n st quad sumlimits_j=1^Jlambda _jx_jmle x_om quad  m=1M  \n quad quad -sumlimits_j=1^Jlambda _jy_jr+s_n^+le -y_on quad  n=1N  \n quad quad sumlimits_j=1^Jlambda _j=1 \n quad quad s_n^+ge 0quad  n=1N  \n quad quad  lambda _jge 0 quad  j=1J  \nendsplit \n\nFor (mathbfx_o, mathbfy_o), this program seeks the maximum feasible increase in outputs while remaining in P(textbfx_o). An observation is technically efficient if the optimal solution (mathbfs^+* mathbflambda^*) is mathbfs^+*=0, with TI_WAtext(Otext)left( textbfx_otextbfy_orho ^+right)=0. Otherwise individual output increases are feasible, and the larger the sum of the slacks, the larger the inefficiency. \n\nThe components of rho_textbfy^+=rho_1^+rho_N^+ in R_++^N represent the relative importance of the unit outputs and are called output weights. Therefore, assigning unitary values, the previous program collapse to the standard output-oriented additive model. As with the Profit Additive model we can change the value of the weights to obtain specific DEA models of the family known as general efficiency measures (GEMs). The relevance of these transformations is that they make the additive measures independent of the units of measurement, which is a desirable property. In the accompanying documentation for this function presented below we present the different options that are available in BenchmarkingEconomicEfficiency.jl.  \n\nFollowing Pastor, Aparicio and Zofio (2022, Ch. 6) we can decompose normalized revenue inefficiency into the technical inefficiency component and the residual allocative measure of cost inefficiency, i.e, RI_WADFleft( O right)left( textbfx_otextbfy_orho _^+ tildetextbfp right) = TI_WADFleft( O right)left( textbfx_otextbfy_o right) + AI_WADFleft( O right)left( textbfx_otextbfy_orho _^+ tildetextbfp right):  \n\nunderbracefracR left( mathbfx_omathbfp right) - sumlimits_n=1^Np_ny_om min leftfracp_1rho _1^+fracp_Nrho _N^+ right_textNorm Revenue Inefficiency=  \n underbrace sumlimits_n=1^Nrho _n^+s_n^+ _textOutput Technical Inefficiency+underbraceAI_RMleft( O right)left( textbfx_otextbfy_orho _^+ tildetextbfp right)_textNorm Allocative Inefficiencyge 0   \n\nReference\n\nChapter 6 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the revenue efficiency additive measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5];\n\nP = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\nrevenueadd = dearevenueadd(X, Y, P, :Ones)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(revenueadd, :Economic)\n\nefficiency(revenueadd, :Technical)\n\nefficiency(revenueadd, :Allocative)","category":"section"},{"location":"revenue/revenueadditive/#dearevenueadd-Function-Documentation","page":"Revenue Additive model","title":"dearevenueadd Function Documentation","text":"","category":"section"},{"location":"revenue/revenueadditive/#BenchmarkingEconomicEfficiency.dearevenueadd","page":"Revenue Additive model","title":"BenchmarkingEconomicEfficiency.dearevenueadd","text":"dearevenueadd(X, Y, P, model)\n\nCompute revenue efficiency using additive data envelopment analysis for inputs X, outputs Y and price of outputs P.\n\nModel specification:\n\n:Ones: standard additive DEA model.\n:MIP: Measure of Inefficiency Proportions. (Charnes et al., 1987; Cooper et al., 1999)\n:Normalized: Normalized weighted additive DEA model. (Lovell and Pastor, 1995)\n:RAM: Range Adjusted Measure. (Cooper et al., 1999)\n:BAM: Bounded Adjusted Measure. (Cooper et al, 2011)\n:Custom: User supplied weights.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nrhoY: matrix of weights of outputs. Only if model=:Custom.\ndisposal=:Strong: chooses strong disposal of inputs. For weak disposal choose :Weak.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitgda/#Profit-General-Direct-Approach-model","page":"Profit General Direct Approach model","title":"Profit General Direct Approach model","text":"The generalized direct approach, GDA, is introduced by Pastor, Aparicio and Zofío (2022, Ch. 13). Contrary to the standard approach that relies on duality theory to obtain a suitable Fenchel-Mahler inequality from which allocative efficiency is recovered as a residual–see Profit Efficiency measurement, the GDA establishes an economic efficiency decomposition valid for any technical efficiency measure, EM(G), by considering the same single equality each time. For any firm left( textbfx_otextbfy_oright) and for an already selected EM(G) we just need to know two pieces of information, its technical inefficiency TI_EM (G)left( textbfx_otextbfy_o right) and its associated frontier projection left( hattextbfx_oEM(G)hattextbfy_oEM(G) right). The GDA, providing a unifying framework for decomposing economic inefficiency, follows similar steps as the traditional approach but is easier to develop and implement since it does not rely on duality theory. It is general, because it can be applied to any efficiency measure; easier to implement, because it does not require to search for Fenchel-Mahler inequalities (although the underlying duality holds); and more reliable, because working with equalities instead of inequalities (and their associated normalization factors) avoids the possibility of overestimating allocative inefficiency as several traditional approaches do when failing to satisfy the essential property.\n\nThe novelty of the proposal is that it breaks up profit inefficiency of firm left( textbfx_o^textbfy_o^ right) into the sum of two components. The first component is the interior product of two vectors, the optimal slack vector left( textbfs_oEM(G)^-*textbfs_oEM(G)^+* right)= left( textbfx_o-hattextbfx_oEM(G)hattextbfy_oEM(G)-textbfy_o right)–corresponding to L_1-path between the firm under evaluation and its projection, and the market price vector left( textbfwtextbfp right); i.e. mathbfpcdot mathbfs_oEM(G)^+*+mathbfwcdot mathbfs_oEM(G)^-*. The second component corresponds to the profit inefficiency at the projection left( hattextbfx_oEM(G)hattextbfy_oEM(G) right). Both components have the intuitive technical and allocative interpretations. This results in the following decomposition:\n\nbeginsplit\n Pi Ileft( mathbfx_omathbfy_omathbfwmathbfp right)=Pi left( mathbfwmathbfp right)-Pi _o=Pi left( mathbfwmathbfp right)-left( mathbfpcdot mathbfy_o^-mathbfwcdot mathbfx_o^ right) =  \n left( mathbfpcdot mathbfs_oEM(G)^+*+mathbfwcdot mathbfs_oEM(G)^-* right)+left( Pi left( mathbfwmathbfp right)-left( mathbfpcdot mathbfhaty_oEM(G)^-mathbfwcdot mathbfhatx_oEM(G)^ right) right)=  \n underbraceleft( mathbfpcdot mathbfs_oEM(G)^+*+mathbfwcdot mathbfs_oEM(G)^-* right)_textProfit textTechnological textGap +underbracePileft(mathbfhatx_oEM(G)mathbfhaty_oEM(G)mathbfwmathbfpright)_textProfit Allocative Inefficiency   \nendsplit\n\nLast equality shows that profit inefficiency, expressed in monetary terms, can be decomposed into the the profit loss due to the technological gap between the firm and its projection, which we term profit technological gap plus the profit inefficiency of its projected benchmark under the given efficiency measure EM(G), representing profit allocative inefficiency. The above expression represents the first step to develop the GDA approach. The second step requires relating the profit technological gap, left( mathbfpcdot mathbfs_oEM(G)^+*+mathbfwcdot mathbfs_oEM(G)^-* right), with the technical inefficiency measure TI_EM(G)left( textbfx_otextbfy_o right) already calculated. The following expression modifies the previous one and shows this relationship:  \n\nbeginsplit\n underbracePi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)_textMonetary Profit Inefficiency=   \n  =underbraceleft( fracmathbfpcdot mathbfs_oEM^+*+mathbfwcdot mathbfs_oEM^-*TI_EM(G)left( mathbfx_o^mathbfy_o^ right) right)times TI_EM(G)left( mathbfx_o^mathbfy_o^ right)_textMonetary Technical Inefficiency+underbraceAI_GDA(G)left( mathbfx_omathbfy_omathbfwmathbfp right)_textMonetary Allocative Inefficiency ge 0  \nendsplit\n\nTherefore, the profit loss associated with the profit technological gap can be decomposed into the technical inefficiency of the firm itself, left( mathbfx_o^mathbfy_o^ right), times a normalizing factor NF_EM(G)left( textbfx_otextbfy_o mathbftildewmathbftildep right) that captures the profit loss per unit of technical inefficiency–the normalizing factor being equal to the profit technological gap divided by the technical inefficiency measure. This correspond to the technical profit inefficiency of the firm and, consequently, the remaining profit inefficiency captured in the second term, which is the difference between overall profit inefficiency and technical profit inefficiency, effectively corresponds to the allocative profit inefficiency of the firm left( mathbfx_o^mathbfy_o^ right). As already shown, this last inefficiency is equivalent to the profit inefficiency at its projection left( mathbfhatx_oEM(G)mathbfhaty_oEM(G) right).\n\nThe final step consists in characterizing the normalizing factor NF_EM(G)left( textbfx_otextbfy_omathbftildewmathbftildep right), which allows us to define a measure of normalized profit inefficiency that is, as the previous ones, units' invariant. For this purpose we differentiate if the firm under evaluation is technically inefficient: TI_EM(G)left( textbfx_otextbfy_o right)0, with left( mathbfx_omathbfy_o right)ne left( mathbfhatx_oEM(G)^mathbfhaty_oEM(G)^ right), or technically efficient: TI_EM(G)left( textbfx_otextbfy_o right) = 0, with left( mathbfx_omathbfy_o right) = left( mathbfhatx_oEM(G)^mathbfhaty_oEM(G)^ right). Hence, we define\n\nNF_EM(G)^GDAleft( mathbfx_o^mathbfy_o^mathbfwmathbfp right)=left \nbeginsplit\n fracleft( mathbfpcdot mathbfs_EM(G)^+*+mathbfwcdot mathbfs_EM^-* right)TI_EM(G)left( mathbfx_o^mathbfy_o^ right)left( mathbfx_omathbfy_o right)ne left( mathbfhatx_oEM(G)^mathbfhaty_oEM(G)^ right)  \n k_ok_o0left(mathbfx_omathbfy_oright)=left(mathbfhatx_oEM(G)^mathbfhaty_oEM(G)^right)\nendsplit\nright\n\nwhere the dollar-valued k_o is a normalization factor for technically efficient firms that, being expressed in the same monetary units, simply translates a null technical efficiency score into the same currency values. With this qualification in mind we can introduce the normalized version of the general direct approach and its associated decomposition: PiI_GDAleft( G right)left( textbfx_otextbfy_otildetextbfw tildetextbfp right) = TI_GDAleft( G right)left( textbfx_otextbfy_o right) +  AI_GDAleft( G right)left( textbfx_otextbfy_o tildetextbfw tildetextbfp right). This results in the following expression: \n\nbeginsplit\n underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)NF_EM(G)^GDAleft( mathbfx_o^mathbfy_o^mathbfwmathbfp right)_textNormtext Profit Inefficiency=  \n quad =underbraceTI_EM(G)left( mathbfx_o^mathbfy_o^ right)_textGraph Technical Inefficiency+ underbraceAI_GDA(G)left( mathbfx_omathbfy_omathbftildewmathbftildep right)_textNormtext Allocative Inefficiency ge 0  \nendsplit\n\nwhere the last term represents normalized allocative inefficiency: AI_GDA(G)left( mathbfx_omathbfy_omathbftildewmathbftildep right) = AI_GDA(G)left( mathbfx_omathbfy_omathbfwmathbfp right)  NF_EM(G)^GDAleft(mathbfx_o^mathbfy_o^mathbfwmathbfp right) \n\nBenchmarkingEconomicEfficiency.jl implements the profit inefficiency decomposition associated with the general direct approach considering the Enhanced Russell graph model. The decomposition can be calculated both in normalized terms, and monetary terms. For this last option one needs to add monetary=true to the syntax–see the documentation below accompanying this function.  \n\nReference\n\nChapter 13 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the profit efficiency General Direct Approach measure for the enhanced Russell graph associated efficiency measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitgda = deaprofitgda(X, Y, W, P, :ERG)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitgda, :Economic)\n\nefficiency(profitgda, :Technical)\n\nefficiency(profitgda, :Allocative)","category":"section"},{"location":"profit/profitgda/#deaprofitgda-Function-Documentation","page":"Profit General Direct Approach model","title":"deaprofitgda Function Documentation","text":"","category":"section"},{"location":"profit/profitgda/#BenchmarkingEconomicEfficiency.deaprofitgda","page":"Profit General Direct Approach model","title":"BenchmarkingEconomicEfficiency.deaprofitgda","text":"deaprofitgda(X, Y, W, P, measure)\n\nCompute profit efficiency using data envelopment analysis General Direct Approach model for inputs X, outputs Y, price of inputs W, price of outputs P, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph (or Slack Based Measure (SBM)).\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\natol=1e-6: tolerance for DMU to be considered efficient.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"revenue/revenuegda/#Revenue-General-Direct-Approach-model","page":"Revenue General Direct Approach model","title":"Revenue General Direct Approach model","text":"The generalized direct approach, GDA, is introduced by Pastor, Aparicio and Zofío (2022, Ch. 13). Contrary to the standard approach that relies on duality theory to obtain a suitable Fenchel-Mahler inequality from which allocative efficiency is recovered as a residual–see Revenue (In)Efficiency measurement, the GDA establishes an economic efficiency decomposition valid for any technical efficiency measure, EM(I), by considering the same single equality each time. For any firm left( textbfx_otextbfy_oright) and for an already selected EM(O) we just need to know two pieces of information, its technical inefficiency TI_EM (O)left( textbfx_otextbfy_o right) and its associated frontier projection left( hattextbfxhattextbfy_oEM(O) right). The GDA, providing a unifying framework for decomposing economic inefficiency, follows similar steps as the traditional approach but is easier to develop and implement since it does not rely on duality theory. It is general, because it can be applied to any efficiency measure; easier to implement, because it does not require to search for Fenchel-Mahler inequalities (although the underlying duality holds); and more reliable, because working with equalities instead of inequalities (and their associated normalization factors) avoids the possibility of overestimating allocative inefficiency as several traditional approaches do when failing to satisfy the essential property.\n\nThe GDA approach breaks up revenue inefficiency of firm left( textbfx_o^textbfy_o^ right) into the sum of two components. The first one corresponds to a technological term which is the interior product of the optimal output slack vector textbfs_oEM(O)^+* = (hattextbfy_oEM(O)-textbfy_o)–-the L_1-path between the firm under evaluation and its projection on the frontier of the output production possibility set P(textbfx_o), and the output price vector textbfp, and a second term measuring the revenue inefficiency of the projected benchmark (textbfx_ohattextbfy_oEM(O)). This results in the following decomposition:\n\nbeginsplit\n RIleft( mathbfx_omathbfy_omathbfp right)= Rleft(mathbfx_omathbfp right)- R_o= Rleft(mathbfx_omathbfp right) - mathbfpcdot mathbfy_o^ =     \n mathbfpcdot mathbfs_oEM(O)^+* + (Rleft(mathbfx_omathbfp right) - mathbfpcdot mathbfhaty_oEM(O)^) =  \n underbracemathbfpcdot mathbfs_oEM(O)^+* _textRevenue textTechnological textGap +underbraceRIleft(mathbfx_o mathbfhaty_oEM(O)mathbfpright)_textRevenue Allocative Inefficiency \nendsplit\n\nLast equality shows that revenue inefficiency, measured in monetary values, can be decomposed into the revenue loss due to the technological gap between the firm and its projection, which we term revenue technological gap, plus the revenue inefficiency of the projected benchmark under the given efficiency measures EM(O), representing revenue allocative inefficiency.  Subsequently we can relate the revenue technological gap, mathbfpcdot mathbfs_oEM(O^+*, with the technical inefficiency measurse TI_EM(O)left( textbfx_otextbfy_o right) of the firm under evaluation, which has been already calculated. The following expression shows this relationship:  \n\nRIleft( mathbfx_omathbfy_omathbfp right)=  \n left( fracmathbfpcdot mathbfs_oEM^+*TI_EM(O)left( mathbfx_o^mathbfy_o^ right) right)times TI_EM(O)left( mathbfx_o^mathbfy_o^ right)+RIleft( mathbfx_omathbfhaty_oEM(G) mathbfp right)  \n\nTherefore, the revenue loss associated with the revenue technological gap can be decomposed into the technical inefficiency of the firm itself, left( mathbfx_o^mathbfy_o^ right), times a normalizing factor NF_EM(O)left( textbfx_otextbfy_omathbftildep right) that captures the revenue loss per unit of technical inefficiency–the normalizing factor being equal to the revenue technological gap divided by the technical inefficiency measure. This corresponds to the technical revenue inefficiency of the firm and, consequently, the remaining cost inefficiency captured in the second term, which is the difference between overall revenue inefficiency and technical revenue inefficiency, effectively corresponds to the allocativerevenue inefficiency of the firm under evaluation left( mathbfx_o^mathbfy_o^ right). As already shown, this last inefficiency is equivalent to the cost inefficiency at its projection left( mathbfx_omathbfy_oEM(O) right). \n\nThe final step consists in characterizing the normalizing factor for the revenue decompositions:NF_EM(O)^GDAleft( textbfx_otextbfy_omathbftildep right), which allow us to define a measure of normalized economic inefficiency that is, as the previous ones, units' invariant. For this purpose we differentiate if the firm under evaluation is technically inefficient or not. That is, if TI_EM(O)left( textbfx_otextbfy_o right)0, with left( mathbfx_omathbfy_o right)ne left( mathbfx_o^mathbfhaty_oEM(O)^ right), or TI_EM(O)left( textbfx_otextbfy_o right) = 0, with left( mathbfx_omathbfy_o right) = left( mathbfx_o^mathbfhaty_oEM(O)^ right). Hence, we define:\n\nNF_EM(O)^GDAleft( mathbfx_o^mathbfy_o^mathbfp right)=left \nbeginsplit\n fracmathbfpcdot mathbfs_EM(O)^+*TI_EM(O)left( mathbfx_o^mathbfy_o^ right)left( mathbfx_omathbfy_o right)ne left( mathbfx_o^mathbfhaty_oEM(O)^ right)  \n k_ok_o0left(mathbfx_omathbfy_oright)=left(mathbfx_o^mathbfhaty_oEM(O)^right)\nendsplit\nright\n\nwhere the dollar-valued k_o is a normalization factor for technically efficient firms that, being expressed in the same monetary units, simply translates a null technical efficiency score into the same currency values. We can introduce the normalized version of the general direct approach and its associated revenue decomposition: RI_GDAleft( O right)left( textbfx_otextbfy_o tildetextbfp right) = TI_GDAleft( O right)left( textbfx_otextbfy_o right) +  AI_GDAleft( O right)left( textbfx_otextbfy_o tildetextbfp right). This results in the following expression: \n\nbeginsplit\n underbracefracR left( mathbfx_omathbfp right) - sumlimits_n=1^Np_ny_omNF_EM(O)^GDAleft( mathbfx_o^mathbfy_o^mathbfp right)_textNormtext Revenue Inefficiency=  \n =underbraceTI_EM(O)left( mathbfx_o^mathbfy_o^ right)_textOutput Technical Inefficiency+ underbraceAI_GDA(O)left( mathbfx_omathbfy_omathbftildep right)_textNormtext Allocative Inefficiency ge 0  \nendsplit\n\nwhere the last term represents normalized allocative inefficiency: AI_GDA(O)left( mathbfx_omathbfy_omathbftildep right) = AI_GDA(O)left( mathbfx_omathbfy_omathbfpright)  NF_EM(O)^GDAleft(mathbfx_o^mathbfy_o^mathbfp right).\n\nBenchmarkingEconomicEfficiency.jl implements the revenue inefficiency decomposition associated with the general direct approach considering the Russell output-oriented model. The decomposition can be calculated both in normalized terms and monetary terms. For the latter one needs to add monetary=true to the syntax–see the documentation below accompanying this function.  \n\nReference\n\nChapter 13 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the cost efficiency General Direct Approach measure for the Russell output measure–the output-oriented enhanced Russell graph measure coincides with the original output Russell measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5];\n\nP = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\nrevenuerddf = dearevenuegda(X, Y, P, :ERG)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(revenuerddf, :Economic)\n\nefficiency(revenuerddf, :Technical)\n\nefficiency(revenuerddf, :Allocative)","category":"section"},{"location":"revenue/revenuegda/#dearevenuegda-Function-Documentation","page":"Revenue General Direct Approach model","title":"dearevenuegda Function Documentation","text":"","category":"section"},{"location":"revenue/revenuegda/#BenchmarkingEconomicEfficiency.dearevenuegda","page":"Revenue General Direct Approach model","title":"BenchmarkingEconomicEfficiency.dearevenuegda","text":"dearevenuegda(X, Y, P, measure)\n\nCompute revenue efficiency using data envelopment analysis General Direct Approach model for inputs X, outputs Y, price of outputs P, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph (or Slack Based Measure (SBM)).\n\nOptional Arguments\n\nrts=:VRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitadditive/#Profit-Additive-model","page":"Profit Additive model","title":"Profit Additive model","text":"The profit additive model is computed by solving an additive DEA model for the technical inefficiency.\n\nThe decomposition of profit inefficiency based on the weighted additive distance function measures graph technical inefficiency based solely on input excesses and output shortfalls, given by the following slack variables: mathbfs^-mathbbin R^M and mathbfs^+mathbbin R^N. When the firm under evaluation (mathbfx_o, mathbfy_o) belongs to the production technology (as it is the case in cross-sectional studies), the DEA graph WADF model for measuring technical inefficiency is equivalent to the standard weighted additive model, which corresponds to the following program:\n\nbeginsplit\n\t\tTI_WADFtext(Gtext)left( textbfx_otextbfy_orho ^-rho ^+ right)= underset\n\t\ttextbfs^-textbfs^+pmblambda \n\tmathoptextmax sumlimits_m=1^Mrho _m^-s_m^-+sumlimits_n=1^Nrho _n^+s_n^+  \n\t st quad sumlimits_j=1^Jlambda _jx_jm+s_m^-le x_om  quad m=1M  \n\t quad quad -sumlimits_j=1^Jlambda _jy_jr+s_n^+le -y_on quad n=1N  \n\t quad quad sumlimits_j=1^Jlambda _j=1   \n\t quad quad s_m^-ge 0 quad m=1M  \n     quad quad s_n^+ge 0 quad n=1N  \n\t quad\tquad lambda _jge 0 quad j=1J  \nendsplit \n\nFor (mathbfx_o, mathbfy_o), this program seeks the maximum feasible reduction in inputs and increase in outputs while remaining in T. An observation is technically efficient if the optimal solution (mathbfs^-* mathbfs^+*lambda^*) is mathbfs^-*=mathbfs^+*=0, so\tTI_WAtext(Gtext)left( textbfx_otextbfy_orho ^-rho ^+ right)=0. Otherwise individual input reductions or output expansions are feasible, and the larger the sum of the slacks, the larger the inefficiency. \n\nThe elements of the vectors of inputs' and outputs' weights: rho_textbfx^-=rho_1^-rho_M^- in R_++^M and rho_textbfy^-=rho_1^+rho_N^+ in R_++^N represent the relative importance of each input and output when measuring technical inefficiency–hence the name of the measure. Therefore, assigning unit values (:Ones), the program corresponds to the standard additive model. However, by choosing alternative weights the WADF encompasses a wide class of different DEA models known as general efficiency measures (GEMs).  As we show below, BenchmarkingEconomicEfficiency.jl allows to choose among a wide range of models. \n\nWe can decompose normalized profit inefficiency into the technical inefficiency component and the residual allocative measure, PiI_WADFleft( G right)left( textbfx_otextbfy_orho _^-rho _^+tildetextbfw tildetextbfp right) = TI_WADFleft( G right)left( textbfx_otextbfy_o right) + AI_WADFleft( G right)left( textbfx_otextbfy_orho _^-rho _^+ tildetextbfw tildetextbfp right):  \n\nbeginsplit\n\t underbracefracPi left( textbfwtextbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)min left fracw_1rho _1^-fracw_Mrho _M^-fracp_1rho _1^+fracp_Nrho _N^+ right_textNormtext Profit Inefficiency=  \n\t quad =underbracesumlimits_m=1^Mrho _m^-s_m^-*+sumlimits_n=1^Nrho _n^+s_n^+*_textGraph Technical Inefficiency+ underbraceAI_WADF(G)left( textbfx_otextbfy_orho ^-rho ^+tildetextbfwtildetextbfp right)_textNormtext Allocative Inefficiency ge 0  \nendsplit\n\nReference\n\nChapter 6 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the profit efficiency additive measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitadd = deaprofitadd(X, Y, W, P, :Ones)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitadd, :Economic)\n\nefficiency(profitadd, :Technical)\n\nefficiency(profitadd, :Allocative)","category":"section"},{"location":"profit/profitadditive/#deaprofitadd-Function-Documentation","page":"Profit Additive model","title":"deaprofitadd Function Documentation","text":"","category":"section"},{"location":"profit/profitadditive/#BenchmarkingEconomicEfficiency.deaprofitadd","page":"Profit Additive model","title":"BenchmarkingEconomicEfficiency.deaprofitadd","text":"deaprofitadd(X, Y, W, P, model)\n\nCompute profit efficiency using data envelopment analysis weighted additive model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nModel specification:\n\n:Ones: standard additive DEA model.\n:MIP: Measure of Inefficiency Proportions. (Charnes et al., 1987; Cooper et al., 1999)\n:Normalized: Normalized weighted additive DEA model. (Lovell and Pastor, 1995)\n:RAM: Range Adjusted Measure. (Cooper et al., 1999)\n:BAM: Bounded Adjusted Measure. (Cooper et al, 2011)\n:Custom: User supplied weights.\n\nOptional Arguments\n\nrhoX: matrix of weights of inputs. Only if model=:Custom.\nrhoY: matrix of weights of outputs. Only if model=:Custom.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitrussell/#Profit-Russell-model","page":"Profit Russell model","title":"Profit Russell model","text":"The profit Russell model is computed by solving a Russell graph DEA model for the technical efficiency.\n\nThe decomposition of profit inefficiency based on the duality between tbe profit function and the Russell measure begins with the calulation of the later according to the following DEA program:\n\nbeginsplit\n\t TE_RM(G)left( textbfx_otextbfy_o right)= undersetbeginsmallmatrix pmbthetapmbphi pmblambda endsmallmatrixmathopmin  frac1M+Nleft( sumlimits_m=1^Mtheta _m+sumlimits_n=1^Nfrac1phi _n right) \n\t st quad sumlimits_j=1^Jlambda _jx_jm=theta _mx_om quad m=1M   \n\t quad quad sumlimits_j=1^Jlambda _jy_jn=phi _ny_on quad n=1N  \n\t quad quad sumlimits_j=1^Jlambda _j=1  \n\t quad quad theta _mle 1 quad m=1M  \n\t quad quad phi _nge 1 quad n=1N  \n\t quad quad lambda _jge 0 quad j=1J  \nendsplit\n\nThe optimal solutions of this program: theta^*_m and phi^*_n, evaluate the relative proportional reduction of input m m=1M, and the relative proportional increase of output n n=1N, respectively. The objective function averages these proportional rates of inputs contraction and outputs expansion. The reference frontier corresponds to the supporting hyperplane defined by the linear combination of the observations that serve as reference benchmark for (mathbfx_omathbfy_o). Those observations, (mathbflambdamathbfXmathbflambdamathbfX), whose associated lambda_j multipliers are greater than zero define the enveloping hyperplane. Although the Russell graph model is non-linear, it is possible to reformulate it as a semidefinite programming (SDP) model. On the one hand, the SDP reformulation of the Russell measure can be solved efficiently using standard SDP solvers. On the other, the dual program allows establishing, for the first time, a dual relationship between the profit function and the Russell measure.\n\nDeparting from TE_RM(G)(textbfx_otextbfy_o) we can define its technical inefficiency counterpart as TI_RM(G)( textbfx_otextbfy_o)=1-TE_RM(G) (textbfx_otextbfy_o). It is then possible to decompose profit inefficiency into technical and allocative components: PiI_RMleft( G right)left( textbfx_otextbfy_otildetextbfw tildetextbfp right) = TI_RMleft( G right)left( textbfx_otextbfy_o right) + AI_RMleft( G right)left( textbfx_otextbfy_o textbfw textbfp right); i.e.,    \n\nbeginsplit\n\t underbracefracPi left( textbfwtextbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)left( M+N right)min left w_1x_o1w_Mx_oMp_1y_o1p_Ny_oN right_textNorm Profit Inefficiency=  \n\t quad = underbraceleft 1-frac1M+Nleft( sumlimits_m=1^Mtheta _m^*+sumlimits_n=1^Nfrac1phi _n^* right) right_textGraph Technical Inefficiency+underbraceAI_RMleft( G right)left( textbfx_otextbfy_otildetextbfwtildetextbfp right)_textNorm Allocative Inefficiencyge 0  \nendsplit\n\nReference\n\nChapter 5 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the profit efficiency Russell measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitrussell = deaprofitrussell(X, Y, W, P)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitrussell, :Economic)\n\nefficiency(profitrussell, :Technical)\n\nefficiency(profitrussell, :Allocative)","category":"section"},{"location":"profit/profitrussell/#deaprofitrussell-Function-Documentation","page":"Profit Russell model","title":"deaprofitrussell Function Documentation","text":"","category":"section"},{"location":"profit/profitrussell/#BenchmarkingEconomicEfficiency.deaprofitrussell","page":"Profit Russell model","title":"BenchmarkingEconomicEfficiency.deaprofitrussell","text":"deaprofitrussell(X, Y, W, P)\n\nCompute profit efficiency using Russell data envelopment analysis for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitefficiency/#Profit-Efficiency-measurement","page":"Profit Efficiency measurement","title":"Profit Efficiency measurement","text":"Profit inefficiency allows studying the economic performance of firms as profit maximizers. Firms are profit efficient if they can maximize the difference between revenue and cost given market prices. The profit function defines as follows:\n\nPi left(mathbfwmathbfpright)=undersetmathbfxmathbfymathoptextmaxBigmathbfpcdot mathbfy-mathbfwcdot mathbfx\n  mathbfx ge Xmathbflambdamathbfy leqslant\nYmathbflambda mathbfmathbfelambda=1 lambda \n\tge mathbf0 Big mathbfwin mathbbR_++^M mathbfpin mathbbR_++^N\n\nCalculating maximum profit along with the optimal output and input quantities through DEA requires solving:\n\nbeginsplit\n\t Pi left( mathbfwmathbfp right)=undersettextbfxtextbfypmblambdamathopmax   sumlimits_n=1^Np_ny_n-sumlimits_m=1^Mw_mx_mquad   \n\t st quad sumlimits_j=1^Jlambda _j^x_jm^le x_m m=1Mtext   \n\t quad quad sumlimits_j=1^Jlambda _j^y_jn^ge y_n^ n=1Ntext   \n\t quad quad sumlimits_j=1^Jlambda _j^=1  \n\t quad quad lambda ge 0quad   \nendsplit\n\nFor a specific firm  left( textbfx_o^textbfy_o^ right)in mathbbR_+^M+N textbfx_o^ne 0_Mtextbfy_o^ne 0_N, Profit inefficiency defines as the difference between maximum profit and observed profit; i.e., mathitPI(textbfx_otextbfy_otextbfw textbfp)= Pileft(mathbfwmathbfpright)- Pi_o= Pileft(mathbfwmathbfpright)- (mathbfpcdot y_o-mathbfwcdot x_o)= Pi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right) ge 0. \n\nThe standard approach decomposing profit inefficiency into a technical inefficiency measure, generally denoted by TI_EM(G)(textbfx_o textbfy_o)–where the subscript EM(G) represents a specific measure, and an allocative term, follows the same methodology regardless the technical measure (e.g., Russell, weighted additive, directional distance function, etc.). \n\nFirst, concerning technical inefficiency measurement, it measures the distance between the firm and the production frontier. If a firm is technically efficient, its value is null, i.e, TI_EM(G)(textbfx_o textbfy_o)=0. Otherwise, if the firm is technically inefficient: TI_EM(G)(textbfx_o textbfy_o)0. After calculating technical inefficiency, and based on the duality between the profit function and each technical inefficiency measure, we can establish a Fenchel-Mahler inequality by which normalized profit inefficiency: PI(textbfx_otextbfy_o tildetextbfw tildetextbfp) =mathitPI(textbfx_otextbfy_otextbfw textbfp)NF_EM(G), is greater or equal in value to the technical inefficiency measure, i.e. mathit PI(textbfx_otextbfy_otextbfw textbfp)NF_EM(G) ge TI_EM(G)(textbfx_o textbfy_o), where the divisor NF_EM(G) is a normalizing scalar derived from the duality relationship. The tilde `~' over prices denotes the normalization of profit inefficiency and its accompanying allocative term. Note that the normalizing factor in the denominator, NF_EM(G) can be applied as divisor to the input and output prices:  (tildetextbfwtildetextbfp) = (textbfwNF_EM(G)textbfpNF_EM(G)).} \n\nAfterwards, a scalar representing normalized allocative inefficiency is obtained as the residual by closing the inequality.  Allocative inefficiency measures the profit loss that can be attributed to the fact that the technically projected benchmark of the firm–through the technical inefficiency measure–does not demand the optimal input quantities or supply the optimal output quantities that jointly maximize profit. \n\nbeginsplit\n underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)NF_EM(G)_textNormtext Profit Inefficiency = \n quad =underbraceTI_EM(G)(textbfx_o textbfy_o)_textGraph Technical Inefficiency+ underbraceAI_EM(G)left( mathbfx_omathbfy_omathbftildewmathbftildep right)_textNormtext Allocative Inefficiency ge 0\nendsplit\n\nThe following functions available in BenchmarkingEconomicEfficiency.jl present alternative decompositions of profit inefficiency based on the most relevant technical inefficiency measures proposed in the literature. As for the decompositions, being normalized, they all satisfy the property of commensurability (or units' invariance), and therefore they are independent of the units of measurement of quantities and prices. Additionally, each of these measures results in a particular decomposition whose pros and cons in terms of a series of properties are inherited from those of the underlying technical inefficiency measure: TI_EM(G)(textbfx_o textbfy_o). Pastor, Aparicio and Zofío (2022, Chap. 14) discuss the properties of the different decompositions proposed in the literature. \n\nReference\n\nChapters 2 and 14 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. ","category":"section"},{"location":"profitability/profitabilitychange/#Profitability-Efficiency-Change","page":"Profitability Efficiency Change","title":"Profitability Efficiency Change","text":"Example\n\nIn this example we compute the profitability efficiency change:\n\nusing BenchmarkingEconomicEfficiency\n\nX1 = [5 3; 2 4; 4 2; 4 8; 7 9]\nY1 = [7 4; 10 8; 8 10; 5 4; 3 6] \nW1 = [2 1; 2 1; 2 1; 2 1; 2 1]\nP1 = [3 2; 3 2; 3 2; 3 2; 3 2]\n\nX2 = [14 12; 8 10; 10 8; 16 20; 14 17]\nY2 = [18 10; 36 28; 28 36; 18 14; 12 20]\nW2 = [3 4; 3 4; 3 4; 3 4; 3 4]\nP2 = [3 5; 3 5; 3 5; 3 5; 3 5]\n\nX = Array{Float64,3}(undef, 5, 2, 2);\nX[:, :, 1] = X1;\nX[:, :, 2] = X2;\n\nY = Array{Float64,3}(undef, 5, 2, 2);\nY[:, :, 1] = Y1;\nY[:, :, 2] = Y2;\n\nW = Array{Float64,3}(undef, 5, 2, 2);\nW[:, :, 1] = W1;\nW[:, :, 2] = W2;\n\nP = Array{Float64,3}(undef, 5, 2, 2);\nP[:, :, 1] = P1;\nP[:, :, 2] = P2;\n\nprofitabilityeffch = deaprofitabilitychange(X, Y, W, P)\n\nEstimated economic, technical CRS and VRS, scale, and allocative efficiency change scores are returned with the effchange function:\n\neffchange(profitabilityeffch, :Economic)\n\neffchange(profitabilityeffch, :CRS)\n\neffchange(profitabilityeffch, :VRS)\n\neffchange(profitabilityeffch, :Scale)\n\neffchange(profitabilityeffch, :Allocative)","category":"section"},{"location":"profitability/profitabilitychange/#DEA-Profitability-Efficiency-Change-Function-Documentation","page":"Profitability Efficiency Change","title":"DEA Profitability Efficiency Change Function Documentation","text":"","category":"section"},{"location":"profitability/profitabilitychange/#BenchmarkingEconomicEfficiency.deaprofitabilitychange","page":"Profitability Efficiency Change","title":"BenchmarkingEconomicEfficiency.deaprofitabilitychange","text":"deaprofitabilitychange(X, Y, W, P)\n\nCompute profitability efficiency change using data envelopment analysis for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nalpha=0.5: alpha to use for the generalized distance function.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profitability/profitabilitychange/#BenchmarkingEconomicEfficiency.effchange-Tuple{ProfitabilityChangeDEAModel, Symbol}","page":"Profitability Efficiency Change","title":"BenchmarkingEconomicEfficiency.effchange","text":"effchange(model::ProfitabilityChangeDEAModel)\n\nReturn efficiency change of a profitability change DEA model.\n\nOptional Arguments\n\ntype=Economic: type of efficiency change scores to return.\n\nType specification:\n\n:Economic: returns economic efficiency change of the model.\n:CRS: returns technical efficiency change under constant returns to scale.\n:VRS: returns technical efficiency change under variable returns to scale.\n:Scale: returns scale efficiency change.\n:Allocative: returns allocative efficiency change.\n\n\n\n\n\n","category":"method"},{"location":"revenue/revenuerussell/#Revenue-Russell-model","page":"Revenue Russell model","title":"Revenue Russell model","text":"The revenue Russell model is computed by solving am output-oriented Russell DEA model for the technical efficiency.\n\nTaking the Russell measure as reference, Pastor, Aparicio and Zofío (2022, Ch. 5) present the Fenchel-Mahler inequality obtained from the dual correspondence between the revenue function and this measure of output technical inefficiency. The Russell output-oriented measure quantifying the technical inefficiency of a firm can be calculated through DEA methods by solving the following program:   \n\nbeginsplit\n TE_RM(O)left( textbfx_otextbfy_o right)= undersetbeginsmallmatrix pmbphi lambda endsmallmatrixmathopmin  frac1N sumlimits_n=1^Nphi _n  \n st quad sumlimits_j=1^Jlambda _jx_jm=x_om quad  m=1M   \n quad quad sumlimits_j=1^Jlambda _jy_jn=phi _ny_on quad  n=1N  \n quad quad sumlimits_j=1^Jlambda _j=1  \n quad quad phi _nge 1 quad n=1N  \n quad quad lambda _jge 0 quad  j=1J  \nendsplit\n\nIn this program phi^*_n evaluates the relative proportional increase of output n n=1N. The objective function averages these proportional rates of output expansion. Contrary to the Russell graph DEA model, this program is linear and therefore easy to calculate through the simplex method. \n\nConsidering TE_RM(O)(textbfx_otextbfy_o) we can define its technical inefficiency counterparts as TI_RM(O)( textbfx_otextbfy_o)=1-TE_RM(O) (textbfx_otextbfy_o). It is then possible to decompose revenue inefficiency into technical and allocative components: RI_RMleft( O right)left( textbfx_otextbfy_otildetextbfp right) = TI_RMleft( O right)left( textbfx_otextbfy_o right) + AI_RMleft( O right)left( textbfx_otextbfy_o tildetextbfp  right). That is    \n\nunderbracefracR left( mathbfx_omathbfp right) - sumlimits_n=1^Np_ny_om  N min left p_1y_o1p_My_oMright_textNorm Revenue Inefficiency= \nunderbrace1-frac1Msumlimits_n=1^Nphi _n^* _textOutput Technical Inefficiency+underbraceAI_RMleft( O right)left( textbfx_otextbfy_otildetextbfp right)_textNorm Allocative Inefficiencyge 0  \n\nReference\n\nChapter 5 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the revenue efficiency Russell measure under variable returns to scale:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5];\n\nP = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\nrevenuerussell = dearevenuerussell(X, Y, P)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(revenuerussell, :Economic)\n\nefficiency(revenuerussell, :Technical)\n\nefficiency(revenuerussell, :Allocative)","category":"section"},{"location":"revenue/revenuerussell/#dearevenuerussell-Function-Documentation","page":"Revenue Russell model","title":"dearevenuerussell Function Documentation","text":"","category":"section"},{"location":"revenue/revenuerussell/#BenchmarkingEconomicEfficiency.dearevenuerussell","page":"Revenue Russell model","title":"BenchmarkingEconomicEfficiency.dearevenuerussell","text":"dearevenuerussell(X, Y, P)\n\nCompute revenue efficiency using Russell data envelopment analysis for inputs X, outputs Y and price of outputs P.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"revenue/revenue/#Revenue-Radial-model","page":"Revenue Radial model","title":"Revenue Radial model","text":"Pastor, Aparicio and Zofío (2022, Ch. 3) summarize the duality results that allow to relate numerically the value of revenue efficiency with that of Farrell's radial output measure R(O)–-whose inverse is Shephard's output distance function. Farrell's measure represents the maximum equiproportional increase in the observed output vector necessary to the reach the production frontier. For the firm under evaluation (mathbfx_omathbfy_o) it can be calculated by solving the following DEA model. \n\nbeginsplit\n TE_R(O)( mathbfx_omathbfy_o) = undersetxi mathbfpmblambda mathopmax quad xi   \n textstextttextquad sumlimits_j=1^Jlambda _j^x_jm^le x_om m=1Mtext   \n quad quad sumlimits_j=1^Jlambda _j^y_jn^ge xi y_on^ n=1Ntext   \n quad quad sumlimits_j=1^Jlambda _j^=1  \n quad quad lambda ge 0 \nendsplit\n\nwhere xi^* denotes now the optimal solution. The constraints require the observation left( mathbfx_oxi^*mathbfy_o right) to belong to the technology P(textbfx_o, while the objective functions seeks the maximum value of xi that projects radially the output vector mathbfy_o to its frontier benchmark represented by hattextbfy_o=xi^*mathbfy_o. A feasible solution signaling technical efficiency is xi^*=1. Therefore if  xi^*1, the observation is technically inefficient and (pmblambda X pmblambda Y) outperforms  left( mathbfx_omathbfy_o right). \n\nWe now show the main duality result relating revenue efficiency and Farrell's radial output distance function, allowing its decomposition:   RE^_R(O)left( textbfx_otextbfy_otextbfp right)=TE_R(O)left( textbfx_otextbftextbfy_o right)+AE_R(O)left( textbfx_otextbfy_otextbfp right), i.e.,\t\t\n\nbeginsplit\n underbracefracsumlimits_n=1^Np_ny_onR(textbfx_otextbfp)_textRevenue Efficiency=underbracexi^*_textTechnical Efficiencytimes underbraceAE_Rleft( O right)left( textbfx_otextbfy_otextbfp right)_textAllocative Efficiency le 1  \nendsplit\n\nExample\n\nIn this example we compute the revnue efficiency measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5];\n\nP = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\nrevenueradial = dearevenue(X, Y, P)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(revenueradial, :Economic)\n\nefficiency(revenueradial, :Technical)\n\nefficiency(revenueradial, :Allocative)\n\nReference\n\nChapter 3 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. ","category":"section"},{"location":"revenue/revenue/#dearevenue-Function-Documentation","page":"Revenue Radial model","title":"dearevenue Function Documentation","text":"","category":"section"},{"location":"revenue/revenue/#DataEnvelopmentAnalysis.dearevenue","page":"Revenue Radial model","title":"DataEnvelopmentAnalysis.dearevenue","text":"dearevenue(X, Y, P)\n\nCompute revenue efficiency using data envelopment analysis for inputs X, outputs Y and price of outputs P.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\ndispos=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"profit/profitmddf/#Profit-Modified-Directional-Distance-Function-model","page":"Profit Modified Directional Distance Function model","title":"Profit Modified Directional Distance Function model","text":"The profit Modified Directional Distance Function **MDDF* is computed by solving the Modified Directional Distance Function model for the technical efficiency.\n\nThe MDDF presents two distinctive advantages over the directional distance function model DDF presented in the associated Profit Directional Distance Function model. First, the normalization factor in the decomposition of profit inefficiency, given by sumlimits_m=1^Mw_m^g_om^-+sumlimits_n=1^Np_n^y_on^+ = C_o+R_o, has no apparent economic interpretation because it corresponds to the monetary sum of the firm's cost and revenue (dollars spent and dollars earned). In turn, the duality of the MDDF with the profit function results in a normalization factor that is either cost or revenue, but not the sum of the two, which results in a meaningful interpretation of profit inefficiency as lost profit on outlay (cost) or lost profit on earnings (revenue). Second, while the DDF reduces inputs and increases outputs in the same proportion beta, the MDDF adds flexibility to the model by allowing for unequal variation in inputs and outputs when attaining technical efficiency. Therefore, the MDDF overcomes these two limitations of the standard DDF: 1) By presenting a dual relationship with the profit function, profit inefficiency has a sensible economic interpretation as either lost profit on outlay (dollar spent or cost) or lost profit on takings (dollar earned or revenue), and 2) it allows managers to adjust inputs and outputs asymmetrically when solving technical inefficiencies.\n\nThe MDDF function can be calculated through DEA methods by solving the following model:\n\nbeginsplit\n TI_MDDF(G)left( textbfx_otextbfy_otextbfg_textbfx^-textbfg_textbfy^+ right)=  undersetbeta _textbfxbeta _textbfypmblambda mathopmax  beta _textbfx+beta _textbfy    \n  st  quad sumlimits_j=1^Jlambda _jx_jmle x_om-beta _textbfxg_x_m^ quad  m=1M  \n  quad quad sumlimits_j=1^Jlambda _jy_jnge y_on+beta _textbfyg_y_n^ quad  n=1N  \n  quad quad sumlimits_j=1^Jlambda _j=1 \n  quad quad  lambda _jge 0 quad  j=1J  \n   quad quad beta _xbeta _yge 0    \nendsplit\n\nwhere, as in the standard DDF, the vector mathbfg= left(mathbfg_x^-mathbfg^+_y right)neqmathbf0_M+N, mathbfg^-_xmathbbin R^M and mathbfg^+_ymathbbin R^N, which is specified by the researcher, sets the direction towards the production frontier. If  the directional vector corresponds is set to the observed input and output quantities of the firm under evaluation: mathbfg= left(mathbfg_x^-mathbfg_y^+ right)=left(mathbfx_otextbfy_o right), and observed profit is non negative: Pi_o ge 0, then the normalization factor relating the profit function and the MDDF, obtained through duality, is equal to observed cost. Therefore we can define the following decomposition of economic inefficiency based on the MDDF: PiI_MDDFleft( G right)left( textbfx_otextbfy_otildetextbfw tildetextbfp right) = TI_MDDFleft( G right)left( textbfx_otextbfy_o right) + AI_MDDFleft( G right)left( textbfx_otextbfy_o tildetextbfw tildetextbfp right). This results in the following expression: \n\nbeginsplit\n underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)C_o_textNormtext Profit Inefficiency=   \n quad =underbracebeta_textbfx^*+beta_textbfy^*_textTechnical Inefficiency+ underbraceAI_DDF(G)left( mathbfx_omathbfy_omathbftildewmathbftildep right)_textNormtext Allocative Inefficiency ge 0  \nendsplit  \n\nwhere beta_textbfx^*+beta_textbfy^* are the solutions to the DEA program. In case the observed firms incurs in economic losses presenting a negative profit, Pi_o0, Pastor, Aparicio and Zofío (2022, Ch. 11) proof that a duality between the profit function and the MDDF can be established in terms of a normalization factor represented by observed revenue. Consequently, a measure of profit loss to earnings can be defined and decomposed as follows: \n\nbeginsplit\n underbracefracPi left( mathbfwmathbfp right)-left( sumlimits_n=1^Np_ny_on-sumlimits_m=1^Mw_mx_om right)R_o_textNormtext Profit Inefficiency=  \n quad =underbracebeta_textbfx^*+beta_textbfy^*_textGraph Technical Inefficiency+ underbraceAI_DDF(G)left( mathbfx_omathbfy_omathbfg_mathbfx^mathbf-mathbfg_mathbfy^+mathbftildewmathbftildep right)_textNormtext Allocative Inefficiency ge 0  \nendsplit \n\nExample\n\nIn this example we compute  profit inefficiency based on the modified directional distance function:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nW = [1; 1; 1; 1; 1; 1; 1; 1];\n\nP = [2; 2; 2; 2; 2; 2; 2; 2];\n\nprofitmddf = deaprofitmddf(X, Y, W, P, Gx = :Observed, Gy = :Observed)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(profitmddf, :Economic)\n\nefficiency(profitmddf, :Technical)\n\nefficiency(profitmddf, :Allocative)\n\nReference\n\nChapter 11 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. ","category":"section"},{"location":"profit/profitmddf/#deaprofitmddf-Function-Documentation","page":"Profit Modified Directional Distance Function model","title":"deaprofitmddf Function Documentation","text":"","category":"section"},{"location":"profit/profitmddf/#BenchmarkingEconomicEfficiency.deaprofitmddf","page":"Profit Modified Directional Distance Function model","title":"BenchmarkingEconomicEfficiency.deaprofitmddf","text":"deaprofitmddf(X, Y, W, P; Gx, Gy)\n\nCompute profit efficiency using Modified DDF data envelopment analysis model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Observed: use observed values.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"revenue/revenueholder/#Revenue-Hölder-model","page":"Revenue Hölder model","title":"Revenue Hölder model","text":"The revenue Hölder model is computed by solving an output-oriented Hölder DEA model for the technical inefficiency.\n\nThe Hölder norms ell _h (hin left 1infty  right) are defined over a g-dimensional real normed space as follows:\n\nleft  right_hzto left z right_h=left beginmatrix\nleft( sumlimits_j=1^gleft z_j right^h right)^1h  textif hin left 1infty  right   \nundersetj=1gmathopmax left left z_j right right  textif h=infty   \nendmatrix right \t\n\nwhere z=left( z_1z_g right)in R^g. \n\nMirroring the options available when decomposing the Profit Hölder model BenchmarkingEconomicEfficiency.jl calculates the technical inefficiency corresponding to the output-oriented Hölder distance functions under the same norms: unit (h=1), infinitum (h=infty), and h=2, corresponding to the Euclidean distance. For norm h=1 the Hölder distance functions are equivalent to the directional distance function presented in the Output-oriented Directional Distance Function with  a specific directional vector. Pastor, Aparicio and Zofío (2022, Ch. 9) show that TI_WHddotolder(O)left( textbfx_otextbfy_o1 right) is calculated as the minimum of the values TI_DDF(O)left( textbfx_otextbfy_o textbf0_M left( 01_left( n right)0 right) right) n=1N. In this case, the output-oriented DDF is solved N times, each with a unit valued element g^-_on=1 for every n output, and the rest of the n-1 elements equal to zero, and considering a zero valued input directional vector. Alternatively, for norm h=infty, the Hölder distance function is also equivalent to the output-oriented DDF model with an unitary  output directional vectors; i.e., TI_WHddotolder(O) left( textbfx_otextbfy_oinfty right) = TI_DDF(I)left( textbfx_otextbfy_o textbf0_M textbf1_N right). Calculating the technical efficiency measures based on the Hölder distance under the Euclidean norm h=2 is complex because determining the shortest distance requires minimizing a convex function on the complement of a convex set. Pastor, Aparicio and Zofío (2022, Ch. 9) show that Euclidean distance from firm (textbfx_otextbfy_o) to the weakly efficient frontier of Pleft( textbfx_o right) can be solved resorting to quadratic optimization. In particular, by solving a bi-level linear program:\n\nbeginsplit\n TI_WHddotolder(I)left( mathbfx_omathbfy_o 2 right)= undersettextbfxtextbfypmblambdabeta pmbgamma mathopmin  sqrtsumlimits_n=1^Nleft( y_n-y_on right)^2  \n\t st quad sumlimits_j=1^Jlambda _jx_jmle x_m quad  m=1M  \n\t  quad quad sumlimits_j=1^Jlambda _jy_jnge y_n quad  n=1N  \n\t quad quad  sumlimits_j=1^Jlambda _j=1   \n\t quad quad beta =0 \n\t quad quad undersetbetapmbgammamathopmax beta    \n\t quad quad stsumlimits_j=1^Jgamma _jx_jmle x_m quad m=1M  \n\t quad quad sumlimits_j=1^Jgamma _jy_jnge y_n+betaquad  n=1N  \n\t quad quad sumlimits_j=1^Jgamma _j=1 \n\t quad quad lambda _jgamma _jge 0 quad j=1J  \n\t quad quad y_nge 0 quad n=1N  \nendsplit\n\nThe literature presents different ways of solving Bi-level Programing models, from exact methods to heuristics and metaheuristics. Here we use the Karush-Kuhn-Tucker conditions of the linear program embedded in the previous model, corresponding to undersetbeta pmbgammamathopmax beta and its associated contraints. Pastor, Aparicio and Zofío (2022, Ch. 9) show that, substituting this program with the corresponding set of complementary constrainst, one can solve the program through second order sets (SOS). Therefore, the final model to be solved is a quadratic programming problem with SOS conditions. BenchmarkingEconomicEfficiency.jl solves the Hölder  model associated to the Euclidean norm using the Gurobi optimizer. This requires adding it to Julia, which can be done under a free license for academic use only, or a paid commercial version. The optimizer can be downloaded from the company's website. A free academic license can be obtained here. Upon installation, add the package Gurobi.jl to Julia by running the following the commands: 'using Pkg', 'Pkg.add(\"Gurobi\")' and 'Pkg.build(\"Gurobi\")'.    \n\nOnce the technical inefficiency measures has been calculated, we recall once again the duality results that allow the decomposition of revenue inefficiency into technical and allocative components: RI_WHddotolder(O)left( textbfx_otextbfy_o h tildetextbfp right) = TI_WHddotolder(O)left( textbfx_otextbfy_o h right) + AI_WHddotolder(O)left( textbfx_otextbfy_o h tildetextbfp right). For the euclidean norm, h=2, this results in the following expression: \n\nunderbracefracR left( mathbfx_omathbfp right) - sumlimits_n=1^Np_ny_omleft p right_q_textNorm Revenue Inefficiency=underbraceundersettextbfylambda beta gamma mathopmin sqrtsumlimits_n=1^Nleft( y_on-y_n^* right)^2_textOutput Technnical Inefficiency+underbraceAI_WHddotolder(O)left( textbfx_otextbfy_o htildetextbfp right)_textNorm Allocative Inefficiency ge 0\n\nwhere y^*_n is the solution to the technical inefficency problem. For the alternative norms h=1 and h=infty the decompositions are equivalent to the Output-oriented Directional Distance Function, where the directional vectors are set to the values previously commented. \n\nFrom the point of view of the satisfaction of properties, a critique associated with the Hölder distance functions is that they do not satisfy units' invariance because they are dependent on the units of measurement of outputs. This means that the comparison between the efficiency scores of different observations would change depending on the units of measurement chosen by the analyst. To solve this problem we can rely on the weighted version of the weakly efficient Hölder distance function (denoted as WW)–for details see Pastor, Aparicio and Zofío (2022, Ch. 9). Based on this distance function, we can decompose revenue inefficiency into technical and allocative inefficiency terms that are units' invariant: RI_WHddotolder(I)left( textbfx_otextbfy_o h tildetextbfp right)= TI_WWHddotolder(O)left( textbfx_otextbfy_oh right) + AI_WWHddotolder(O)left( textbfx_otextbfy_o h tildetextbfp right). For the Euclidean norm, h=2, this results in: \n\nunderbracefracR left( mathbfx_omathbfp right) - sumlimits_n=1^Np_ny_omleft p right_q_textNorm Revenue Inefficiency=underbraceundersettextbfylambda beta gamma mathopmin sqrtsumlimits_n=1^Nleft(fracy_m^*-y_oy_omright)^2_textOutput Technnical Inefficiency+underbraceAI_WWHddotolder(O)left( textbfx_otextbfy_o htildetextbfp right)_textNorm Allocative Inefficiency ge 0\n\nBenchmarkingEconomicEfficiency.jl calculates both the unweighted and weighted versions of the revenue Hölder model under the previous norms: ell _1,  ell _infty , and ell _2. The weighted version requires adding weight=true to the code–see below the documentation accompanying this function for the different options. \n\nReference\n\nChapter 9 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the revenue efficiency Hölder L1 measure under variable returns to scale:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5];\n\nP = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\nrevenueholder = dearevenueholder(X, Y, P, l = 1)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(revenueholder, :Economic)\n\nefficiency(revenueholder, :Technical)\n\nefficiency(revenueholder, :Allocative)","category":"section"},{"location":"revenue/revenueholder/#dearevenueholder-Function-Documentation","page":"Revenue Hölder model","title":"dearevenueholder Function Documentation","text":"","category":"section"},{"location":"revenue/revenueholder/#BenchmarkingEconomicEfficiency.dearevenueholder","page":"Revenue Hölder model","title":"BenchmarkingEconomicEfficiency.dearevenueholder","text":"dearevenueholder(X, Y, W; l)\n\nCompute revenue efficiency using data envelopment analysis for inputs X, outputs Y and price of outputs P.\n\nHölder norm l specification\n\n1.\n2.\nInf.\n\nOptional Arguments\n\nweigt=false:  set to true for weighted (weakly) Hölder distance function.\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"cost/costgda/#Cost-General-Direct-Approach-model","page":"Cost General Direct Approach model","title":"Cost General Direct Approach model","text":"The generalized direct approach, GDA, is introduced by Pastor, Aparicio and Zofío (2022, Ch. 13). Contrary to the standard approach that relies on duality theory to obtain a suitable Fenchel-Mahler inequality from which allocative efficiency is recovered as a residual–see Cost (In)Efficiency measurement, the GDA establishes an economic efficiency decomposition valid for any technical efficiency measure, EM(I), by considering the same single equality each time. For any firm left( textbfx_otextbfy_oright) and for an already selected EM(I) we just need to know two pieces of information, its technical inefficiency TI_EM (I)left( textbfx_otextbfy_o right) and its associated frontier projection left( hattextbfx_oEM(I)textbfy_o right). The GDA, providing a unifying framework for decomposing economic inefficiency, follows similar steps as the traditional approach but is easier to develop and implement since it does not rely on duality theory. It is general, because it can be applied to any efficiency measure; easier to implement, because it does not require to search for Fenchel-Mahler inequalities (although the underlying duality holds); and more reliable, because working with equalities instead of inequalities (and their associated normalization factors) avoids the possibility of overestimating allocative inefficiency as several traditional approaches do when failing to satisfy the essential property.\n\nThe GDA approach breaks up cost inefficiency of firm left( textbfx_o^textbfy_o^ right) into the sum of two components. The first one corresponds to a technological term which is the interior product of two vectors: the optimal input slack vector textbfs_oEM(G)^-*= (textbfx_o-hattextbfx_oEM(I))–corresponding to L_1-path between the firm under evaluation and its projection on the frontier of the input production possibility set L(textbfy_o), and the input price vector textbfw. The second allocative component corresponds to cost inefficiency at the projection left( hattextbfx_oEM(I)textbfy_o right). Both components have the intuitive technical and allocative interpretations. This results in the following decomposition:\n\nbeginsplit\n CIleft( mathbfx_omathbfy_omathbfw right)=C_o - Cleft(mathbfy_omathbfw right)= mathbfwcdot mathbfx_o^ - Cleft(mathbfy_omathbfw right) =   \n mathbfwcdot mathbfs_oEM(I)^-* + (mathbfwcdot mathbfhatx_oEM(I)^ - Cleft(mathbfy_omathbfw right)) =  \n underbracemathbfwcdot mathbfs_oEM(I)^-* _textCost textTechnological textGap +underbraceCIleft(mathbfhatx_oEM(I)mathbfy_omathbfwright)_textCost Allocative Inefficiency \nendsplit\n\nLast equality shows that cost inefficiency, measured in monetary values, can be decomposed into the cost excess due  to the technological gap between the firm and its projection, which we term cost technological gap, plus the cost inefficiency of the projected benchmark under the given efficiency measures EM(I), representing cost allocative inefficiency.  Subsequently we can relate the cost technological gap, mathbfwcdot mathbfs_oEM(I)^-*, with the technical inefficiency measurse TI_EM(I)left( textbfx_otextbfy_o right) of the firm under evaluation, which has been already calculated. The following expression shows this relationship:  \n\nCIleft( mathbfx_omathbfy_omathbfwright)= \nleft( fracmathbfwcdot mathbfs_oEM^-*TI_EM(I)left( mathbfx_o^mathbfy_o^ right) right)times TI_EM(I)left( mathbfx_o^mathbfy_o^ right)+CIleft( mathbfhatx_oEM(I)mathbfy_omathbfwright)  \n\nTherefore, the cost excess associated with the cost technological gap can be decomposed into the technical inefficiency of the firm itself, left( mathbfx_o^mathbfy_o^ right), times a normalizing factor NF_EM(I)left( textbfx_otextbfy_omathbftildew right) that captures the cost excess per unit of technical inefficiency–the normalizing factor being equal to the cost technological gap divided by the technical inefficiency measure. This corresponds to the technical cost inefficiency of the firm and, consequently, the remaining cost inefficiency captured in the second term, which is the difference between overall cost inefficiency and technical cost inefficiency, effectively corresponds to the allocative cost inefficiency of the firm under evaluation left( mathbfx_o^mathbfy_o^ right). As already shown, this last inefficiency is equivalent to the cost inefficiency at its projection left( mathbfhatx_oEM(I)mathbfy_o right). \n\nThe final step consists in characterizing the normalizing factor for the cost decompositions: NF_EM(I)^GDAleft( textbfx_otextbfy_omathbftildew right), which allow us to define a measure of normalized economic inefficiency that is, as the previous ones, units' invariant. For this purpose we differentiate if the firm under evaluation is technically inefficient or not. That is, if TI_EM(I)left( textbfx_otextbfy_o right)0, with left( mathbfx_omathbfy_o right)ne left( mathbfhatx_oEM(I)^mathbfy_o^ right), or TI_EM(I)left( textbfx_otextbfy_o right) = 0, with left( mathbfx_omathbfy_o right) = left( mathbfhatx_oEM(I)^mathbfy_o^ right). Hence, we define:\n\nNF_EM(I)^GDAleft( mathbfx_o^mathbfy_o^mathbfw right)=left \nbeginsplit\n fracmathbfwcdot mathbfs_EM^-* TI_EM(I)left( mathbfx_o^mathbfy_o^ right)left( mathbfx_omathbfy_o right)ne left( mathbfhatx_oEM(I)^mathbfy_o^ right)  \n k_ok_o0left(mathbfx_omathbfy_oright)=left(mathbfhatx_oEM(I)^mathbfy_o^right)\nendsplit\nright\n\nwhere the dollar-valued k_o is a normalization factor for technically efficient firms that, being expressed in the same monetary units, simply translates a null technical efficiency score into the same currency values. We can introduce the normalized version of the general direct approach and its associated cost decomposition: CI_GDAleft( I right)left( textbfx_otextbfy_otildetextbfw right) = TI_GDAleft( I right)left( textbfx_otextbfy_o right) +  AI_GDAleft( I right)left( textbfx_otextbfy_o tildetextbfw right). This results in the following expression: \n\nbeginsplit\n underbracefracsumlimits_m=1^Mw_mx_om-Cleft( textbfy_otextbfw right)NF_EM(I)^GDAleft( mathbfx_o^mathbfy_o^mathbfp right)_textNormtext Cost Inefficiency=  \n =underbraceTI_EM(I)left( mathbfx_o^mathbfy_o^ right)_textInput Technical Inefficiency+ underbraceAI_GDA(I)left( mathbfx_omathbfy_omathbftildewright)_textNormtext Allocative Inefficiency ge 0  \nendsplit\n\nwhere the last term represents normalized allocative inefficiency: AI_GDA(I)left( mathbfx_omathbfy_omathbftildew right) = AI_GDA(I)left( mathbfx_omathbfy_omathbfwright)  NF_EM(G)^GDAleft(mathbfx_o^mathbfy_o^mathbfw right).\n\nBenchmarkingEconomicEfficiency.jl implements the cost inefficiency decomposition associated with the general direct approach considering the Russell input-oriented model. The decomposition can be calculated both in normalized terms and monetary terms. For the latter one needs to add monetary=true to the syntax–see the documentation below accompanying this function.  \n\nReference\n\nChapter 13 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the cost efficiency General Direct Approach measure for the Russell input measure–the input-oriented enhanced Russell graph measure coincides with the original input Russell measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\nW = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\ncostgda = deacostgda(X, Y, W, :ERG)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(costgda, :Economic)\n\nefficiency(costgda, :Technical)\n\nefficiency(costgda, :Allocative)","category":"section"},{"location":"cost/costgda/#deacostgda-Function-Documentation","page":"Cost General Direct Approach model","title":"deacostgda Function Documentation","text":"","category":"section"},{"location":"cost/costgda/#BenchmarkingEconomicEfficiency.deacostgda","page":"Cost General Direct Approach model","title":"BenchmarkingEconomicEfficiency.deacostgda","text":"deacostgda(X, Y, W, measure)\n\nCompute cost efficiency using data envelopment analysis General Direct Approach model for inputs X, outputs Y, price of inputs W, and efficiency measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph (or Slack Based Measure (SBM)).\n\nOptional Arguments\n\nrts=:VRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"cost/costadditive/#Cost-Additive-model","page":"Cost Additive model","title":"Cost Additive model","text":"The cost additive model is computed by solving an input-oriented additive DEA model for the technical inefficiency.\n\nThe decomposition of cost inefficiency based on the weighted additive distance function measures input-oriented  technical inefficiency based solely on input excesses, given by the following slack variables: mathbfs^-mathbbin R^M. When the firm under evaluation (mathbfx_o, mathbfy_o) belongs to the production technology (as it is the case in cross-sectional studies), the DEA graph WADF model for measuring technical inefficiency is equivalent to the standard weighted additive model, which corresponds to the following DEA program:\n\nbeginsplit\n TI_WADFleft( I right)left( textbfx_otextbfy_orho ^- right)= undersetbeginsmallmatrix pmbs^- pmblambda endsmallmatrixmathopmax  sumlimits_m=1^Mrho _m^-s_m^- \n st quad sumlimits_j=1^Jlambda _jx_jm+s_m^-le x_om quad m=1M   \n quad quad -sumlimits_j=1^Jlambda _jy_jnle -y_on quad  n=1N   \n quad quad sumlimits_j=1^Jlambda _j=1  \n quad quad s_m^-ge 0 quad  m=1M  \n quad quad lambda _jge 0 quad  j=1J   \nendsplit \n\nFor (mathbfx_o, mathbfy_o), this program seeks the maximum feasible reduction in inputs while remaining in L(textbfy_o). An observation is technically efficient if the optimal solution (mathbfs^-* mathbflambda^*) is mathbfs^-*=0, with TI_WAtext(Otext)left( textbfx_otextbfy_orho ^-right)=0. Otherwise individual input reductions are feasible, and the larger the sum of the slacks, the larger the inefficiency. \n\nThe components of rho_textbfx^-=rho_1^-rho_M^- in R_++^M represent the relative importance of the unit inputs and are called input weights. Therefore, assigning unitary values, the previous program collapse to the standard input-oriented additive model. As with the Profit Additive model we can change the value of the weights to obtain specific DEA models of the family known as general efficiency measures (GEMs). The relevance of these transformations is that they make the additive measures independent of the units of measurement, which is a desirable property. In the accompanying documentation for this function presented below we present the different options that are available in BenchmarkingEconomicEfficiency.jl. \n\nFollowing Pastor, Aparicio and Zofio (2022, Ch. 6) we can  decompose normalized cost inefficiency into the technical inefficiency component and the residual allocative measure of cost inefficiency, i.e., CI_WADFleft( I right)left( textbfx_otextbfy_orho _^-tildetextbfw right) = TI_WADFleft( I right)left( textbfx_otextbfy_o right) + AI_WADFleft( I right)left( textbfx_otextbfy_orho _^- tildetextbfw right):  \n\nunderbracefracsumlimits_m=1^Mw_mx_om - C left( mathbfy_omathbfw right)min left fracw_1rho _1^-fracw_Mrho _M^- right_textNorm Cost Inefficiency= underbrace sumlimits_m=1^Mrho _m^-s_m^-_textInput Technical Inefficiency+underbraceAI_WADFleft( I right)left( textbfx_otextbfy_orho _^-tildetextbfw right)_textNorm Allocative Inefficiencyge 0   \n\nReference\n\nChapter 6 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. \n\nExample\n\nIn this example we compute the cost efficiency additive measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\nW = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\ncostadd = deacostadd(X, Y, W, :Ones)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(costadd, :Economic)\n\nefficiency(costadd, :Technical)\n\nefficiency(costadd, :Allocative)","category":"section"},{"location":"cost/costadditive/#deacostadd-Function-Documentation","page":"Cost Additive model","title":"deacostadd Function Documentation","text":"","category":"section"},{"location":"cost/costadditive/#BenchmarkingEconomicEfficiency.deacostadd","page":"Cost Additive model","title":"BenchmarkingEconomicEfficiency.deacostadd","text":"deacostadditive(X, Y, W, model)\n\nCompute cost efficiency using additive data envelopment analysis for inputs X, outputs Y and price of inputs W.\n\nModel specification:\n\n:Ones: standard additive DEA model.\n:MIP: Measure of Inefficiency Proportions. (Charnes et al., 1987; Cooper et al., 1999)\n:Normalized: Normalized weighted additive DEA model. (Lovell and Pastor, 1995)\n:RAM: Range Adjusted Measure. (Cooper et al., 1999)\n:BAM: Bounded Adjusted Measure. (Cooper et al, 2011)\n:Custom: User supplied weights.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\nrhoX: matrix of weights of inputs. Only if model=:Custom.\ndisposal=:Strong: chooses strong disposal of outputs. For weak disposal choose :Weak.\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"#BenchmarkingEconomicEfficiency.jl","page":"Home","title":"BenchmarkingEconomicEfficiency.jl","text":"BenchmarkingEconomicEfficiency.jl is a Julia package that provides functions for economic efficiency using Data Envelopment Analysis (DEA). The package is an extension of the DataEnvelopmentAnalysis.jl package.\n\nThe package is being developed for Julia 1.0 and above on Linux, macOS, and Windows.\n\nThe packes uses internally the JuMP modelling language for mathematicall optimization with solvers GLPK and Ipopt.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed with the Julia package manager:\n\njulia> using Pkg; Pkg.add(\"BenchmarkingEconomicEfficiency\")","category":"section"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"For a tutorial on how to use the package, check the documentation on the Cost Directional Distance Function model.","category":"section"},{"location":"#Available-models","page":"Home","title":"Available models","text":"Profit DEA models:\n\nPages = [\"profit/profitefficiency.md\", \"profit/profitrussell.md\", \"profit/profitadditive.md\", \"profit/profitenhancedrussell.md\", \"profit/profitddf.md\", \"profit/profitholder.md\",  \"profit/profitmddf.md\", \"profit/profitrddf.md\", \"profit/profitgda.md\"]\nDepth = 2\n\nProfitability DEA models:\n\nPages = [\"profitability/profitability.md\"]\nDepth = 2\n\nCost DEA models:\n\nPages = [\"cost/costefficiency.md\", \"cost/cost.md\", \"cost/costrussell.md\", \"cost/costadditive.md\", \"cost/costddf.md\", \"cost/costholder.md\", \"cost/costrddf.md\", \"cost/costgda.md\"]\nDepth = 2\n\nRevenue DEA models:\n\nPages = [\"revenue/revenueefficiency.md\", \"revenue/revenue.md\",  \"revenue/revenuerussell.md\", \"revenue/revenueadditive.md\", \"revenue/revenueddf.md\", \"revenue/revenueholder.md\", \"revenue/revenuerddf.md\", \"revenue/revenuegda.md\"]\nDepth = 2","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"BenchmarkingEconomicEfficiency.jl is being developed by Javier Barbero and José Luís Zofío.","category":"section"},{"location":"cost/cost/#Cost-Radial-model","page":"Cost Radial model","title":"Cost Radial model","text":"Pastor, Aparicio and Zofío (2022, Ch. 3) summarize the duality results that allow to relate numerically the value of cost efficiency with that of Farrell's radial input measure R(I)–whose inverse is Shephard's input distance function. Farrell's measure represents the maximum equiproportional reduction in the observed input vector necessary to the reach the production frontier. For the firm under evaluation (mathbfx_omathbfy_o) it can be calculated by solving the following DEA model. \n\nbeginsplit\n TE_R(I)( mathbfx_omathbfy_o) = undersettheta mathbfpmblambda mathopmin quad theta   \n textstextttextquad sumlimits_j=1^Jlambda _j^x_jm^le thetax_om m=1Mtext   \n quad quad sumlimits_j=1^Jlambda _j^y_jn^ge y_n^ n=1Ntext   \n quad quad sumlimits_j=1^Jlambda _j^=1  \n quad quad lambda ge 0 \nendsplit\n\nDenoting the optimal solution to this program by theta^*, the constraints require the projection left( theta^*mathbfx_omathbfy_o right) to belong to the technology L(textbfy_o), while the objective functions seeks the minimum value of theta that projects radially the input vector mathbfx_o to its frontier benchmark represented by hattextbfx_o=theta^*mathbfx_o. A feasible solution signaling technical efficiency is theta^*=1. Therefore if  theta^*1, the observation is technically inefficient and (pmblambda Xpmblambda Y) outperforms  left( mathbfx_omathbfy_o right). \n\nWe can now show the main duality result relating cost efficiency and Farrell's radial input distance function R(I), allowing its decomposition:   CE^_R(I)left( textbfx_otextbfy_otextbfw right)=TE_R(I)left( textbfx_otextbftextbfy_o right)+AE_R(I)left( textbfx_otextbfy_otextbfw right), i.e.,\t\t\n\nbeginsplit\n underbracefracC(textbfy_otextbfw)sumlimits_m=1^Mw_mx_om_textCost Efficiency=underbracetheta^*_textTechnical Efficiencytimes underbraceAE_Rleft( I right)left( textbfx_otextbfy_otextbfw right)_textAllocative Efficiency le 1 \nendsplit\n\nExample\n\nIn this example we compute the cost efficiency measure:\n\nusing BenchmarkingEconomicEfficiency\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\nW = [1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1; 1 1];\n\ncostradial = deacost(X, Y, W)\n\nEstimated economic, technical and allocative efficiency scores are returned with the efficiency function:\n\nefficiency(costradial, :Economic)\n\nefficiency(costradial, :Technical)\n\nefficiency(costradial, :Allocative)\n\nReference\n\nChapter 3 in Pastor, J.T., Aparicio, J. and Zofío, J.L. (2022) Benchmarking Economic Efficiency: Technical and Allocative Fundamentals, International Series in Operations Research and Management Science, Vol. 315,  Springer, Cham. ","category":"section"},{"location":"cost/cost/#deacost-Function-Documentation","page":"Cost Radial model","title":"deacost Function Documentation","text":"","category":"section"},{"location":"cost/cost/#DataEnvelopmentAnalysis.deacost","page":"Cost Radial model","title":"DataEnvelopmentAnalysis.deacost","text":"deacost(X, Y, W)\n\nCompute cost efficiency using data envelopment analysis for inputs X, outputs Y and price of inputs W.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\ndispos=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"}]
}
